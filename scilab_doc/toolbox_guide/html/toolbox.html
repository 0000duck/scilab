<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
	<head>
		<title>Toolbox Guide</title>
		<link rel="stylesheet" href="toolbox.css" type="text/css">
	</head>
	
	<body>
		<h1 center>Guide for the toolboxes contribution (general application)<br /><hr></h1>
		<p>
			This article describes a standart method to create a Scilab toolbox.<br />
			The objective is to help the contributors to build a toolbox easily, but also that the users are able to install it with just the execution of a main builder and a main loader script.<br />
			We show in first time how to structure your toolbox (sub-directories contents, files, ...), in second time how to customize the templates to create the builder(s), the loader(s), and the Scilab help files. To finish we explain how to upload your contribution on the scilab website.<br />
			For this article the reference toolbox name is <b>toolbox_example</b>.
			(The above standarisation is not mandatory)
		</p>
		
		<h2>Table of content</h2>
		
		<ul>
			<a href="#chap1">1. Toolbox composition</a><br />
			<a href="#chap2">2. Sub-builders and sub-loaders</a><br />
			<ul>
				<a href="#chap2.1">2.1. The macros directory</a><br />
				<ul>
					<a href="#chap2.1.1">2.1.1. Creation of the builder</a><br />
					<a href="#chap2.1.2">2.1.2. Creation of the loader</a><br />
				</ul>
				<a href="#chap2.2">2.2. The src directory</a><br />
				<ul>
					<a href="#chap2.2.1">2.2.1. Interface</a><br />
					<a href="#chap2.2.2">2.2.2. Creation of the builder</a><br />
				</ul>
					<a href="#chap2.3">2.3. The man directory</a><br />
				<ul>
					<a href="#chap2.3.1">2.3.1. Creation of .xml files</a><br />
					<a href="#chap2.3.2">2.3.2. Creation of the builder</a><br />
					<a href="#chap2.3.3">2.3.3. Creation of the loader</a><br />
				</ul>
			</ul>
			<a href="#chap3">3. The main builder and loader</a><br />
			<a href="#chap4">4. Upload your toolbox</a><br />
		</ul>
		
		<a name="chap1"></a>
		<h2>1. Toolbox composition</h2>
		<p>The root directory has the generic name of the toolbox (here <b>toolbox_example</b>), it contains 7 sub-directories:</p> 
		
		<ul style="list-style-type: disc">
			<li><b>macros</b>: Scilab macros (all .sci files),the builder and loader scripts</li>
			<li><b>src</b>: code source (all .c and .f  files), a builder script</li>
			<li><b>interface</b>: interface programs, a builder</li>
			<li><b>man</b>: all .xml files, the builder and loader scripts</li>
			<li><b>doc</b>: .html, .pdf, .txt, .jpeg, ...</li>
			<li><b>tests</b>: scripts to test your toolbox</li>
			<li><b>demos</b>: different examples to illustrate your toolbox</li>
		</ul>
		
		and 3 files:
		
		<ul style="list-style-type: disc">
			<li><b>README</b>: toolbox description and installation</li>
			<li><b>builder.sce</b></li>
			<li><b>loader.sce</b></li>
		</ul>
		
		<a name="chap2"></a>
		<h2>2. Sub-builders and sub-loaders</h2>
			<p>
				The main builder and main loader scripts launch respectively the sub-builders and sub-loaders included in the sub-directories (macros, src, man, ...), to generate and to load the necessary libraries and the Scilab help files.
			</p>
		
		<a name="#chap2.1"></a>
		<h3>2.1 The macros directoy</h3>
		<p>
			The main builder and main loader scripts launche respectively the sub-builders and sub-loaders included in the sub-directories (macros, man, ...), to generate and to load the necessary libraries and the Scilab help files.
			This directory included macros Scilab functions, a builder and a loader script.<br />
			A  macros is a function written in Scilab code (included in .sci file)<br />
			We consider that the macros directory of the toolbox <b>toolbox_example</b> contains just one .sci file: the function <var><strong>foo1</strong></var> (see above script). Given a matrix A, this function returns the positive components of the A diagonal.
		</p>
		foo1.sci<br />
		
		<pre class="entete">
function [X]=foo1(A)
	// This function returns the positive components of the A diagonal
	
	// Check the type and the size of A
	if  type(A)<>1 then
		error("type of input argument must be a double");
	end
	if  size(A,1)<>size(A,2) then
		error("input argument must be a square matrix");
	end
	//Extraction of the positive components
	X=[];
	for i=1:size(A,1)
		if A(i,i)>0 then
			X($+1)=A(i,i);
		end
	end
endfunction</pre>
		
		<a name="chap2.1.1"></a>
		<h4>2.1.1 Creation of the builder</h4>
		<p>
			The builder (see above script) creates a library variable, (named here: toolbox_examplelib= toolbox name +'lib')
			from functions .sci  include in the directory macros, and saves it in the file lib.
			The builder code is generic, it's done in 2 steps, the first to locate macrosbuilder.sce script 
			(see help <var><strong>get_absolute_file_path</strong></var> function), and the second to generate the library
			(see help <strong><var>genlib</strong></var> function). 
		</p>
		builder.sce
		<pre class="entete">
mode(-1)
toolboxname='toolbox_example'
pathB=get_absolute_file_path('builder.sce')
disp('Building macros  in ' +pathB)
genlib(toolboxname+'lib',pathB,%t)
clear pathB genlib toolboxname</pre>	
		
		<br />
		To customize this template, replace the characters string 'toolbox_example' by the name of your toolbox.
		
		<a name="chap2.1.2"></a>
		<h4>2.1.2 Creation of the loader</h4>
		<p>
			The loader (see above script) loads the library lib included in the directory macros. Like the builder, the code is generic, the first step to locate macrosloader.sce script, and the second to load the library (see help <strong><var>load</strong></var> function)
		</p>
		
		loader.sce
		<pre class="entete">
mode(-1)
pathL=get_absolute_file_path('loader.sce')
disp('Loading macros  in ' +pathL)
load(pathL+'/lib')
clear pathL</pre>	
		
		<a name="chap2.2"></a>
		<h3>2.2 The src directory</h3>
		<p>
			This directory included .c files and a builder script<br />
			A Scilab primitive is a Scilab function which calls a function written in C or fortran code (using an interface program)<br />
			Before to write the builder, its necessary to create for each primitives the corresponding interface programs. When a Scilab primitive is called, the interface program checks that the number, the type and the size of  inputs/outputs arguments is correct (using CheckRhs and CheckLhs functions), and get the adress of the rhs arguments which are in Scilab internal stack to give this information at the interfaced function. So in the first part we explain, thanks to template, how to implement some interfaces programs (written in C code). In this article we don't describe all the possibilities of the interface programs, for more explanations see the directory SCI/examples.  
		</p>
		
		<a name="chap2.2.1"></a>
		<h4>2.2.1 Interface</h4>
		<p>
			Here two examples which enable to write many interfaces, so it's important to understand it, and know how to customize it for your toolbox. 
		</p>
		
		<p>
			<EM>Example a</EM>: <br />             
			We consider an C routine sumab which returns the sum of  two vectors. I suppose that the name of the corresponding primitive is 
			<var><strong>scisum</strong></var>. We can keep the same name that the C routine (sumab) or try an other name.<br />
			The both following scripts represent the C code of <var><strong>sumab</strong></var> and its associated interface program when 
			we call the primitive <var><strong>scisum </strong></var>in a Scilab window as follows:<br />
			<var><strong>--> Y=scisum(A,B )</strong></var> <br /><br />
		</p>
		
		sumab.c 
		<pre class="entete">
void sumab(int n, double * a, double * b, double * y)
{
	int k;
	for (k = 0; k < n; ++k) 
	y[k] = a[k] + b[k];
}</pre>	
			
		<br />
		intsumab.c<br />
		<pre class="entete">
#include "stack-c.h"
extern int sumab(int n, double * a, double * b, double * y); 

void intsumab(char *fname){  
int l1, m1, n1, l2, m2, n2, l3, n;   
		
/* 1 - Check the nuumber of input/output arguments  */  
int minlhs=1, maxlhs=1, minrhs=2, maxrhs=2; 
CheckRhs(minrhs,maxrhs) ; 
CheckLhs(minlhs,maxlhs) ; 

/* 2 - Check input arguments type and get input arguments adress in the Scilab stack */  
GetRhsVar(1, "d", &m1, &n1, &l1);
GetRhsVar(2, "d", &m2, &n2, &l2);
		
/* 3 - Check that the input arguments have the same size */
n=m2*n2; 
if( n1!=n2 || m1!=m2) 
{
	cerro("input arguments must have the same size"); 
	return 0; 
}	
if(n1!=0 && m1!=0)    
	if(n1!=1 && m1!=1)   
	{
		cerro("input arguments must be vectors");    
		return(0); 
	}
		
/* it's possible to use the chekdims and getscalar functions: a completer ................*/  
		
/* 4 - Create the output argument */ 
CreateVar(3,"d",&m2,&n2,&l3);   
sumab(n,stk(l1),stk(l2),stk(l3));  
		
/* 5 - Specif the ouput argument */  
LhsVar(1) = 3;  
return 0;
}</pre>	            
		
		<br />
		<p>
			<EM>In Step 1</EM>: call the instructions <var><strong>CheckRhsVar(minrhs,maxrhs)</strong></var> and <var><strong>
			CheckLhsVar(minlhs,maxlhs)</strong></var><br />
			<var><strong>CheckRhsVar</strong></var> function uses the arguments <strong><var>minrhs</strong></var> 
			and <var><strong>maxrhs</strong></var> to check that:<br />
			<var><strong>minrhs <= number of  input arguments <= maxrhs</strong></var><br />
			In this example the numbers of input (=2) and output (=1) arguments are constant, but for certains functions (see example2)
			they can be variable, in this case the variables <var><strong>minrhs/minlhs</strong></var> and <var><strong>maxrhs/maxlhs</strong>
			</var> are different.<br /> We can use directly the defined variables <var><strong>Rhs</strong></var>(=number of inputs) and 
			<var><strong>Lhs</strong></var>(=number of outputs) instead of the functions <var><strong>CheckRhsVar</strong></var>  and  
			</var><strong>CheckLhsVar</strong></var>.<br />
			
			<br />
			
			<EM>In Step 2</EM>:  call the instruction <b><i>GetRhsVar(1,"d",&m1,&n1,&l1)</b></i><br />
			<b><i>GetRhsVar</b></i> function checks that the type of inputs argument is correct, and gets their size and their adress in the Scilab stack.<br />
			We describe above all arguments of <b><i>GetRhsVar</b></i> function:<br />
			<b><i>1</b></i> : corresponds to the position of the first input argument of scisum(A,B ), i.e A, (2 corresponds to B,...)<br />
			<b><i>m1 </b></i>: gets the rows number of A (m2 for B)<br />
			<b><i>n1 </b></i>: gets the columns number of  A (n2 for B)<br />
			<b><i>l1 </b></i>: gets the adress of A in the Scilab stack (l2 for B)<br />
			
			<br />
			
			<EM>In Step 3</EM>: instruction <b><i>CreateVar(3,"d",&m2,&n2,&l3)</b></i><br />
			<b><i>CreateVar</b></i>  function creates the ouput argument (here Y) at the 3th position<br />
			<b><i>3 </b></i>: corresponds to the position of the first output argument Y. We should take the number which follows 
			immediatly the last position of  the input arguments (which is 2)<br />
			<b><i>"d"</b></i>: sets the type of the output argument, a double <br />
			<b><i>m2</b></i>: sets the rows number of the output argument (here equal to the rows number of the second input argument B: m2)<br />
			<b><i>n2</b></i>: sets the columns number of the first output argument (here equal to the columns number of the second input argument B: n2)<br />
			<b><i>l3</b></i>: gets the adress of the lhs in the Scilab stack <br />
			
			<br />
			
			<EM>In Step 4</EM>: instruction <b><i>LhsVar(1) = 3</b></i><br />
			The instruction <b><i>LhsVar(1) = 3</b></i> means the first output argument take the value of the variable placed in the 3th position (i.e Y)<br />
			
			<br />
			<br />
			
			<EM>Example b</EM>:<br />
				In the second example we describe the interface program (see above script) of the primitive </b></i>scifun1</b></i> which uses the C functions <b><i>fun1</b></i> and <b><i>fun2</b></i> (see above script). This primitive have two syntaxes:<br />
			
			<br />
			the first syntax is:</b></i><br />
			<b><i>--> [X, Y ]=scifun1(A);</b></i><br />
			Given a vector <b><i>A</b></i>, this function returns the positive components of <b><i>A</b></i> in a vector <b><i>X</b></i> and the sum of its positive components in a scalar <b><i>Y</b></i>. In this case the number of output arguments (=Lhs) is 2.<br />
			
			<br />
			the second syntax is:<br />
			<b><i>--> [X ]=scifun1(A);</b></i><br />
			Given a vector <b><i>A</b></i>, this function returns the positive components of <b><i>A</b></i> in a vector <b><i>X</b></i>. In this case <b><i>Lhs=1</b></i>.<br />
		</p>
		
		<br />
		fun1.c 
		<pre class="entete">
extern void  fun2(double *, int, int *);

void fun1(double * a,  int na, int * nb,  double ** b , double * positive_sum){
	int i, k1=0;
	*positive_sum=0;
	fun2(a, na, nb);
	*b=(double *)malloc((*nb)*sizeof(double));
	*positive_sum=0;
	for(i=0;i<na;i++)
	if(a[i]>0) {
		*(*b+k1)=a[i];
		*positive_sum += a[i];
		k1++;
	};
}</pre>	
		
		<br />
		
		fun2.c
		<pre class="entete">
void  fun2(double * a, int na, int * m)
{
	int i;
	*m=0;
	for(i=0;i<na;i++)
	if (a[i]>0)  
		(*m)++;
}</pre>	
		
		<br />
		
		intfun1.c
		<pre class="entete">
#include "stack-c.h"

extern void fun1(double * ,  int, int *, double **, double *);

int intfun1(char *fname)
{
	int l1, m1, n1, m=1, nX, i, l2, l3;
	double * X, S;

	/* 1 - Check the number of inputs and outputs arguments */
	/* You can use the variables: Lhs and Rhs */
	int minlhs=1, maxlhs=2, minrhs=1, maxrhs=1;
	CheckRhs(minrhs,maxrhs) ;
	CheckLhs(minlhs,maxlhs) ;

	/* 2 - Check rhs type, get the rows number (m1) and the columns number (n1) of rhs, and its adress (l1) in the Scilab stack */
	GetRhsVar(1, "d", &m1, &n1, &l1); 

	/* 3 - Check rhs is a vector */
	if(m1!=0 && n1!=0 )
	{
		if(m1!=1 && n1!=1)
		{
			cerro("input argument must be a vector");
			return(0);
		}
	}

	fun1(stk(l1), n1*m1, &nX, &X, &S);

	/* 4 - Create the place for the first output X ( a vector of doubles, size: m*n ) to the adress l2 in the Scilab stack */
	CreateVar(2, "d", &m, &nX, &l2);

	/* if there are two outputs variable then: Create the place for the second output S ( a double, size 1*1) to the adress l3 in the Scilab stack */ 
	/* get the value of S, and put it in the Scilab stack */
	if(Lhs==2)
	{
		CreateVar(3, "d", &m, &m, &l3);
		*stk(l3)=S;
	}

	/* get the components of  X, and put them in the Scilab stack */
	for(i=0;i&gt;nX;i++) 
		stk(l2)[i]=X[i];

	/* free memory */
	free(X);

	/* 5 - Specification of outputs variables */
	LhsVar(1) = 2;
	if(Lhs==2)
		LhsVar(2) = 3;
	return 0;
}</pre>	
		
		<br />
		
		<a name="chap2.2.2"></a>
		<h4>2.2.2 Creation of the builder</h4>
		<p>
			Now the src directory of the toolbox toolbox_example contains all the necessary files (<b><i>fun1.c</b></i>,
		 	<b><i>fun2.c</b></i>, <b><i>intfun1.c</b></i>, <b><i>sumab.c</b></i>, <b><i>intsumab.c</b></i>) to create the 
			 builder (see above template) for the primitives scifun1 and scisum.
			<br />
			We need to write two builders: one the hand, the src builder (see above script) which creates a shared libraries (see help <i><b>ilib_for_link</b></i> function) corresponding to the .c functions. 
			And the other hand, the interface builder (see above script) which creates new shared libraries to link the compiled C or Fortran 
			new Scilab interface routines (thanks to src libraries), and generates a loader (see help <i><b>ilib_build</b></i> function). 
			This loader file calls the addinter function to dynamically load the shared library (see help <i><b>addinter</b></i> function)
		</p>
		
		the src builder
		<pre class="entete">
ilib_for_link('toolboxsrc',['fun1.o' 'fun2.o','sumab.o'],[],"c")</pre>	
		
		<br />
		the interface builder<br />
		
		<pre class="entete">
// must be run from this directory
ilib_name  = 'libtoolbox_example'     // interface library name
files = ['intfun1.o', 'intsumab.o'];  // objects files
libs  = ["../src/libtooloxsrc"]                 // other libs needed for linking
table = [ 'scifun1', 'intfun1';
	'scisum','intsumab'];        // table of (scilab_name,interface-name)
// do not modify below
ilib_build(ilib_name,table,files,libs)</pre>	
		
		<br />	
		<br />
		
		<a name="chap2.2.2"></a>
		<h4>2.2.2 Creation of the builder</h4>
		<p>Now the src directory of the toolbox toolbox_example contains all the necessary files (<b><i>fun1.c</b></i>, <b><i>fun2.c</b></i>, <b><i>intfun1.c</b></i>, <b><i>sumab.c</b></i>, <b><i>intsumab.c</b></i>) to create the builder (see above template) for the primitives scifun1 and scisum.
		<br />
		We need to write two builders: one the hand, the src builder (see above script) which creates a shared libraries (see help <i><b>ilib_for_link</b></i> function) corresponding to the .c functions. 
		And the other hand, the interface builder (see above script) which creates new shared libraries to link the compiled C or Fortran 
		new Scilab interface routines (thanks to src libraries), and generates a loader (see help <i><b>ilib_build</b></i> function). 
		This loader file calls the addinter function to dynamically load the shared library (see help <i><b>addinter</b></i> function)</p>
		
		the src builder
		<pre class="entete">
ilib_for_link('toolbox_examplesrc',['fun1.o' 'fun2.o','sumab.o'],[],"c")</pre>	
		
		<br />
		the interface builder<br />
		
		<pre class="entete">
// must be run from this directory
ilib_name  = 'libtoolbox_example'     // interface library name
files = ['intfun1.o', 'intsumab.o'];  // objects files
libs  = ["../src/libtoolbox_examplesrc"]                 // other libs needed for linking
table = [ 'scifun1', 'intfun1';
	'scisum','intsumab'];        // table of (scilab_name,interface-name)
// do not modify below
ilib_build(ilib_name,table,files,libs)</pre>	
		
		<br />
		The <i><b>ilib_name</b></i> value is the interface library name, the vector <i><b>files</b></i> contains all the object interface files,  
		the vector <i><b>libs</b></i> contains the libraries needed for linking (here the library included in the src directory), 
		the variable <i><b>table</b></i> contains the primitives names (first column) and the corresponding interface program names (second column)
		
		<a name="chap2.3"></a>
		<h3>2.3 The  man directory</h3>
		<p>This directory included .xml files, a manbuilder and a manloader scripts
				On Unix/Linux systems: to create the manual pages you need 'sabcmd', an XML parser which is part of the Sablotron package.<br /> 
				(here link to download it:<A href="http://www.scilab.org/download/index_download.php?page=related_tool.html">  http://www.scilab.org/download/index_download.php?page=related_tool.html</A>)<br />
				(.................... a completer  ............................)
		</p>
		
		<a name="chap2.3.1"></a>
		<h4>2.3.1 Creation of .xml files</h4>
		<p> 
		Here a template which helps you to write the .xml help files. You should just fill the different items(Langage, title, type, date, short description, ...) for the .xml files of your functions (here <b><i>foo1.xml</i></b>, <b><i>scifun1.xml</i></b>, <b><i>scisum.xml</i></b>) and put them in the man directory.
		</p>
		
		<pre class="entete">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; standalone=&quot;no&quot;?&gt;
&lt;!DOCTYPE MAN SYSTEM &quot;/home/scilab/scilab-3.0/man/manrev.dtd&quot;&gt;
&lt;MAN&gt;
&lt;LANGUAGE&gt;eng&lt;/LANGUAGE&gt;
&lt;TITLE&gt;scifoo2&lt;/TITLE&gt;
&lt;TYPE&gt;Scilab Function  &lt;/TYPE&gt;
&lt;DATE&gt;20-Mar-2006&lt;/DATE&gt;
&lt;SHORT_DESCRIPTION name=&quot;add function name&quot;&gt;  add short decription here&lt;/SHORT_DESCRIPTION&gt;

&lt;CALLING_SEQUENCE&gt;
&lt;CALLING_SEQUENCE_ITEM&gt;add function syntax&lt;/CALLING_SEQUENCE_ITEM&gt;
&lt;/CALLING_SEQUENCE&gt;

&lt;PARAM&gt;
&lt;PARAM_INDENT&gt;
&lt;PARAM_ITEM&gt;
&lt;PARAM_NAME&gt;add param name&lt;/PARAM_NAME&gt;
&lt;PARAM_DESCRIPTION&gt;
&lt;SP&gt;
: add here the parameter description
&lt;/SP&gt;
&lt;/PARAM_DESCRIPTION&gt;

&lt;PARAM_ITEM&gt;
&lt;PARAM_NAME&gt;add param name&lt;/PARAM_NAME&gt;
&lt;PARAM_DESCRIPTION&gt;
&lt;SP&gt;
: add here the parameter description
&lt;/SP&gt;
&lt;/PARAM_DESCRIPTION&gt;
&lt;/PARAM_ITEM&gt;
&lt;/PARAM_INDENT&gt;
&lt;/PARAM&gt;

&lt;DESCRIPTION&gt;
&lt;DESCRIPTION_INDENT&gt;
&lt;DESCRIPTION_ITEM&gt;
&lt;P&gt;
Add here a paragraph of the function description. 
Other paragraph can be added 
&lt;/P&gt;
&lt;/DESCRIPTION_ITEM&gt;
&lt;DESCRIPTION_ITEM&gt;
&lt;P&gt;
Add here a paragraph of the function description 
&lt;/P&gt;
&lt;/DESCRIPTION_ITEM&gt;
&lt;/DESCRIPTION_INDENT&gt;
&lt;/DESCRIPTION&gt;

&lt;EXAMPLE&gt;&lt;![CDATA[
Add here scilab instructions and comments
]]&gt;&lt;/EXAMPLE&gt;

&lt;SEE_ALSO&gt;
&lt;SEE_ALSO_ITEM&gt; &lt;LINK&gt; add a key here&lt;/LINK&gt; &lt;/SEE_ALSO_ITEM&gt;
&lt;SEE_ALSO_ITEM&gt; &lt;LINK&gt; add a key here&lt;/LINK&gt; &lt;/SEE_ALSO_ITEM&gt;
&lt;/SEE_ALSO&gt;

&lt;BIBLIO&gt;
Add here the function bibliography if any
&lt;/BIBLIO&gt;

&lt;AUTHORS&gt;
&lt;AUTHORS_ITEM label='enter here the author name'&gt;
Add here the author  references
&lt;/AUTHORS_ITEM&gt;
&lt;/AUTHORS&gt;
&lt;USED_FUNCTIONS&gt;
Add here the used function name and  references
&lt;/USED_FUNCTIONS&gt;
&lt;/MAN&gt;</pre>	
		
		<a name="chap2.3.2"></a>
		<h4>2.3.2 Creation of the builder</h4>
		<p>The manbuilder (see above) creates a whatis.htm file which is a short description of the functions, and translates the xml files to html (see help xmltohtml function)
		</p>
		
		<br />
		
		builder.sce
		<pre class="entete">
mode(-1) //force silent execution
path=get_absolute_file_path('builder.sce');//get the absolute path of this file
add_help_chapter("Title1",path);//add help chapter
xmltohtml(path,"Title1")
//clear the variable stack
clear path add_help_chapter get_absolute_file_path </pre>	
		
		<a name="chap2.3.3"></a>
		<h4>2.3.3 Creation of the loader</h4>
		<p>The loader(see above script) add your help functions files in the help Scilab browser 
		</p>
		
		loader.sce
		<pre class="entete">
mode(-1) //force silent execution
path=get_absolute_file_path('loader.sce');//get the absolute path of this file
add_help_chapter("Title1",path);//add help chapter
clear path add_help_chapter get_absolute_file_</pre>	
		
		<a name="chap3"></a>
		<h2>3. The main builder and loader</h2>
		The builder and loader are generic, they execute all sub-builder(s) and sub-loader(s), here the both scripts:<br /><br />
		
		builder.sce
		<pre class="entete">
mode(-1);
mainpathB=get_absolute_file_path('builder.sce');
chdir(mainpathB);
if isdir('src') then
chdir('src');
exec('builder.sce');
chdir('..');
end
if isdir('interface') then
chdir('interface');
exec('builder.sce');
chdir('..');
end
if isdir('macros') then
chdir('macros');
exec('builder.sce');
chdir('..');
end
if isdir('man') then
chdir('man');
exec('builder.sce');
chdir('..');
end
clear mainpathB</pre>	
		
		<br />
		
		loader.sce
		<pre class="entete">
mode(-1);
mainpathL=get_absolute_file_path('loader.sce');
chdir(mainpathL);
if isdir('interface') then
chdir('interface');
exec('loader.sce');
chdir('..');
end
if isdir('macros') then
chdir('macros');
exec('loader.sce');
chdir('..');
end
if isdir('man') then
chdir('man');
exec('loader.sce');
chdir('..');
end
clear mainpathL</pre>	

		<a name="chap4"></a>
		<h2>4. Upload your toolbox</h2>
		<ul style="list-style-type: disc">
			<li>Read the instructions about how to contribute , see the link: 
				<A href="http://www.scilab.org/contrib/index_contrib.php?page=howto.html">http://www.scilab.org/contrib/index_contrib.php?page=howto.html </A></li>
				<li>Archive and Compress your toolbox: </li>
				<li>Complete the submission form document and add your package (here <b>toolbox_example.tar.gz</b> and <b>toolbox_example.zip</b>), 
					see the link: <A href="http://www.scilab.org/contrib/index_contrib.php?page=upload.html">http://www.scilab.fr/contrib/index_contrib.php?page=upload.html </A></li>
		</ul>
	</body>
</html>
