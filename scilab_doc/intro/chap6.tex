% Copyright INRIA

%\documentclass[11pt]{article}
%\textwidth=6in
%\textheight=8.5in 
%\oddsidemargin=.30in%.25in
%\evensidemargin=.30in%.25in
%\topmargin=-.25in
%\parskip.3cm
%\begin{document}

\chapter{Interfacing C or Fortran programs with Scilab}

Scilab can be easily interfaced with Fortran or C programs. 
This is useful to have faster code or to use specific numerical
code for, e.g., the simulation or optimization of
user defined systems, or specific Lapack or {\tt netlib} modules. 
In fact, interfacing numerical code appears necessary in most
nontrivial applications. For
interfacing C or Fortran programs, it is of course necessary to link
these programs with Scilab. This can be done by a dynamic
(incremental) link or by creating a new executable code for Scilab.
For executing a C or Fortran program linked with Scilab, its
input parameters must be given specific values transferred from Scilab
and its output
parameters must be transformed into Scilab variables.
It is also possible that a linked program is automatically executed
by a high-level primitive: for instance the {\tt ode} function
can integrate the differential equation $\dot{x} = f(t,x)$ with a
rhs function $f$ defined as a C or Fortran program which is
dynamically linked to Scilab (see \ref{refexternals}).


The simplest way to call external programs is to use the  
{\tt link}\index{link@{\tt link}} primitive
(which dynamically links the user's program with Scilab)
and then to interactively call
the linked routine by {\tt call}\index{call@{\tt call}} primitive
which transmits Scilab variables (matrices or strings) to the linked program
and transforms back the output parameters into Scilab variables. 
Note that ode/dae solvers and non linear optimization primitives
can be directly used with C or Fortran user-defined programs
dynamically linked (see \ref{dynamiclink}). . 

An other way to add C or Fortran code to Scilab is by 
building an interface program. The interface program can be written by
the user following the examples given in the following directories
{\tt routines/examples/interface-tutorial} and {\tt routines/examples/interface-tour}. Examples of Matlab-like interfaces are given in the directory
{\tt routines/examples/mexfiles}.

The interface program can also be generated by {\tt
intersci}. {\tt Intersci} builds the interface
program from a {\tt .desc} file which describes both the C or 
Fortran program(s) to be used and the name and parameters of
the corresponding Scilab function(s). 

Finally  it is possible to add a permanent new primitive to Scilab
by building an interface program as above and making a new executable
code for Scilab. This is done by updating the {\tt fundef}
file. In this case, the interface program should be given a specific 
name (e.g. the default name {\tt matus2}) and a number. The file 
{\tt default/fundef} should also be updated as done by {\tt intersci}.
A new executable code is generated by typing ``make all''
in the main Scilab directory.

\section{Using dynamic link}
Several simple examples of dynamic link are  given in the directory
{\tt examples/link-examples}. In this section, we briefly describe 
how to call a dynamically linked program. 
\subsection{Dynamic link}
\label{dynamiclink}
The command {\tt link('path/pgm.o','pgm',flag)}
links the compiled program {\tt pgm} to Scilab.
Here {\tt pgm.o} is an object file located in the {\tt path}
directory and {\tt pgm} is an entry point (program name) in the file {\tt pgm.o}
(An object file can have several entry points: to link them, use a vector of
character strings such as \verb!['pgm1','pgm2']!).

{\tt flag} should be set to {\tt 'C'} for a C-coded program
and to {\tt 'F'} for a Fortran subroutine. ({\tt 'F'} is
the default flag and can be omitted).

If the link operation is OK, scilab returns an integer {\tt n} associated
with this linked program. To undo the link enter {\tt ulink(n)}.

The command \verb!c_link('pgm')! returns true if {\tt pgm} is
currently linked to Scilab and false if not.

\noindent
Here is a example, with the Fortran BLAS {\tt daxpy} subroutine 
used in Scilab:
\begin{verbatim}

-->n=link(SCI+'/routines/blas/daxpy.o','daxpy')
linking files /usr/local/lib/scilab-2.4/routines/calelm/daxpy.o
to create a shared executable.
Linking daxpy (in fact daxpy_)
Link done
 n  =
 
    0.  
 
-->c_link('daxpy')
 ans  =
 
  T  

-->ulink(n)
 
-->c_link('daxpy')
 ans  =
 
  F  
\end{verbatim}

For more details, enter {\tt help link}.

\subsection{Calling a dynamically linked program}

The {\tt call} function can be used to call a dynamically linked
program. Consider for example the {\tt daxpy} Fortran routine. It performs 
the simple vector operation {\tt y=y+a*x} or, to be more specific, 
\begin{verbatim}
y(1)=y(1)+a*x(1), y(1+incy)=y(1+incy)+a*x(1+incx),...
y(1+n*incy)=y(1+n*incy)+a*x(1+n*incx)
\end{verbatim} 
where {\tt y} and {\tt x} are two real vectors.
The calling sequence for {\tt daxpy} is as follows:
\begin{verbatim}
      subroutine daxpy(n,a,x,incx,y,incy)
\end{verbatim}
To call {\tt daxpy} from Scilab we must use a syntax as follows: 
\begin{verbatim}
[y1,y2,y3,...]=call('daxpy', inputs description, ...
                    'out', outputs description)
\end{verbatim}
\noindent
Here {\tt inputs description} is a set of parameters
 
{\tt x1,p1,t1}, {\tt x2,p2,t2}, {\tt x3,p3,t3} ... 

\noindent
where {\tt xi} is the Scilab variable (real vector or matrix) sent to 
{\tt daxpy},
{\tt pi} is the position number of this variable in the calling
sequence of {\tt daxpy} and {\tt ti} is the type of {\tt xi} in {\tt daxpy}
({\tt t='i'  t='r'  t='d'} stands for integer, real or double).

\noindent
{\tt outputs description} is a set of parameters
 
{\tt [r1,c1],p1,t1}, {\tt [r2,c2],p2,t2}, {\tt [r3,c3],p3,t3},..

\noindent
which describes each output variable. {\tt [ri,ci]} is the
2 x 1 integer vector giving the number of rows and columns of the
ith output variable {\tt yi}. {\tt pi} and {\tt ti} are as for
input variables (they can be omitted if a variable is both input and
output). 

We see that the arguments of {\tt call}  divided into four groups.
The first argument {\tt 'daxpy'} is the name of the called subroutine.
The argument {\tt 'out'} divides the remaining arguments into two 
groups.  The group of arguments between {\tt 'daxpy'} and {\tt 'out'}
is the list of input arguments, their positions in the call to {\tt daxpy},
and their data type.  The group of arguments to the right of {\tt 'out'}
are the dimensions of the output variables, their positions in the call
to {\tt daxpy}, and their data type.
The possible data types are real, integer, and double precision which
are indicated, respectively, by the strings {\tt 'r'}, {\tt 'i'}, and
{\tt 'd'}.  
Here we calculate {\tt y=y+a*x} by a call to {\tt daxpy} (assuming
that the {\tt link} command has been done).
We have six input variables 
{\tt x1=n, x2=a, x3=x, x4=incx, x5=y, x6=incy}.
Variables {\tt x1, x4} and {\tt x6} are integers and variables
{\tt x2, x3, x5} are double. There is one output variable {\tt y1=y}
at position {\tt p1=5}. To simplify, we assume here that {\tt x} and
{\tt y} have the same length and we take {\tt incx=incy=1}.
\begin{verbatim}
-->a=3;
 
-->x=[1,2,3,4];
 
-->y=[1,1,1,1];
 
-->incx=1;incy=1;

-->n=size(x,'*');

-->y=call('daxpy',...
        n,1,'i',...
        a,2,'d',...
        x,3,'d',...
        incx,4,'i',...
        y,5,'d',...
        incy,6,'i',...
'out',...
        [1,n],5,'d');

 y  =
 
!   4.    7.    10.    13. !

\end{verbatim}
(Since {\tt y} is both input and output parameter, we could also use
the simplified syntax 
{\tt call(...,'out',5)} instead of {\tt call(...,'out'[1,n],5,'d')}). 

The same example with the C function {\tt daxpy} (from CBLAS):
\begin{verbatim}
int daxpy(int *n, double *da, double *dx, int *incx, double *dy, int *incy)
...
\end{verbatim}

\begin{verbatim}
-->link('daxpy.o','daxpy','C')
linking files daxpy.o  to create a shared executable
Linking daxpy (in fact daxpy)
Link done
 ans  =
 
    1.  

-->y=call('daxpy',...
        n,1,'i',...
        a,2,'d',...
        x,3,'d',...
        incx,4,'i',...
        y,5,'d',...
        incy,6,'i',...
'out',...
        [1,n],5,'d');
 
-->y
 y  =
 
!   4.    7.    10.    13. !
\end{verbatim}

The routines which are linked to Scilab can also access internal 
Scilab variables: see the examples in given in the {\tt examples/links}
directory.

\section{Interface programs}

\subsection{Building an interface program}
Examples of interface programs are given in the directory 
{\tt examples/interface-tutorial} and {\tt examples/interface-tour}. 

The interface programs use a set of C or 
Fortran routines which should be used to build the interface program.
The simplest way to learn how to build an interface program is to
customize the previous skeletons files and to look at the examples
provided in this directory. 
Note that a unique interface program can be used to interface an 
arbitrary (but less that $99$) number of functions.

\subsection{Example}
\label{interface}
Let us consider an example given in {\tt examples/interface-tutorial}.

We have the following C function \verb!matmul! which performs 
a matrix multiplication. Only the calling sequence is important.
\scriptsize
\begin{verbatim}
/*Matrix multiplication C=A*B, (A,B,C stored columnwise) */

#define A(i,k) a[i + k*n]
#define B(k,j) b[k + j*m]
#define C(i,j) c[i + j*n]

void matmul(a,n,m,b,l,c)
double a[],b[],c[];
int n,m,l;
{
int i,j,k; double s;
for( i=0 ; i < n; i++)
   {
     for( j=0; j < l; j++)
        {
        s = 0.;
        for( k=0; k< m; k++)
           {
	    s += A(i,k)*B(k,j);
           }
         C(i,j) = s;
         }
   }
}
\end{verbatim}
\normalsize

We want to have a new Scilab function (also called \verb!matmul!)
which is such that the Scilab command 
\begin{verbatim}
-->C=matmul(A,B)
\end{verbatim}
returns in \verb!C! the matrix product \verb!A*B! computed
by the above C function. Here \verb!A, B! and \verb!C! are standard
numeric Scilab matrices. Thus, the Scilab matrices \verb!A! and \verb!B! 
should be sent to the C function \verb!matmul! and the matrix 
\verb!C! should be created, filled, and sent back to Scilab.

To create the Scilab function \verb!matmul!, we have to write 
the following C gateway function called
\verb!intmatmul!. See the file \newline
\verb!SCIDIR/examples/interface-tutorial/intmatmul.c!.

\scriptsize
\begin{verbatim}
#include "stack-c.h"

int intmatmul(fname) 
     char *fname;
{
  static int l1, m1, n1, l2, m2, n2, l3;
  static int minlhs=1, maxlhs=1, minrhs=2, maxrhs=2;

  /* Check number of inputs (Rhs=2) and outputs (Lhs=1) */
  CheckRhs(minrhs,maxrhs) ; CheckLhs(minlhs,maxlhs) ;

  /* Get A (#1) and B (#2) as double ("d") */
  GetRhsVar(1, "d", &m1, &n1, &l1); 
  GetRhsVar(2, "d", &m2, &n2, &l2); 

  /* Check dimensions    */
if (!(n1==m2)) {Scierror(999,"%s: Uncompatible dimensions\r\n",fname);
                 return 0;}

  /* Create C (#3) as double ("d") with m1 rows and n1 columns */
  CreateVar(3, "d", &m1, &n2, &l3);   

  /* Call the multiplication function matmul
     inputs:stk(l1)->A, stk(l2)->B  output:stk(l3)->C    */
  matmul(stk(l1), m1, n1, stk(l2), n2, stk(l3));

  /*  Return C (3)  */
  LhsVar(1) = 3;
  return 0;
}
\end{verbatim}
\normalsize

Let us now explain each step of the gateway function \verb!intmatmul!.
The gateway function must include the file \verb!SCIDIR/routines/stack-c.h!.
This is the first line of the file. 
The name of the routine is \verb!intmatmul!
and it admits one input parameter which is \verb!fname!. 
\verb!fname! must be declared as \verb!char *!. The name of the gateway
routine (here \verb!intmatmul!) is arbitrary but the parameter 
\verb!fname! is compulsory.
The gateway routine then includes the declarations of the C variables used.
In the gateway function \verb!intmatmul! the Scilab matrices 
\verb!A!, \verb!B! and \verb!C! are referred to as numbers,
respectively \verb!1!, \verb!2! and \verb!3!. 

The line 
\begin{verbatim}
CheckRhs(minrhs,maxrhs); CheckLhs(minlhs,maxlhs);
\end{verbatim}
is to check that the Scilab function \verb!matmul! is called with
a correct number of RHS and LHS parameters. For instance, typing 
\verb!-->matmul(A)! will give an error message made by \verb!CheckRhs!.
The function \verb!CheckRhs! just compares the C variable \verb!Rhs!
(transmitted in the include file \verb!stack-c.h!) with the bounds
\verb!minrhs! and \verb!maxrhs!.

\noindent
The next step is to deal with the Scilab variables \verb!A!, \verb!B! 
and \verb!C!. In a gateway function, all the Scilab variables
are referred to as numbers. Here, the Scilab matrices 
\verb!A!, \verb!B! and \verb!C! are 
respectively numbered \verb!1!, \verb!2! and \verb!3!. 
Each input variable of the newly created Scilab function
\verb!matmul! (i.e. \verb!A! and \verb!B!)
should be processed by a call to \verb!GetRhsVar!.
The first two parameters of  \verb!GetRhsVar! are inputs and the last
three parameters are outputs.
The line 
\begin{verbatim}
GetRhsVar(1, "d", &m1, &n1, &l1); 
\end{verbatim}
means that we process the RHS variable numbered \verb!1! (i.e. \verb!A!).
The first parameter of \verb!GetRhsVar! (here \verb!1!) refers to the
first parameter (here \verb!A!) of the Scilab function \verb!matmul!.
This variable is a Scilab numeric matrix which should be seen ("d") as a 
\verb!double! C array, since the C routine \verb!matmul! is
expecting a \verb!double! array. The second parameter of \verb!GetRhsVar!
(here \verb!"d"!) refers to the type (double, int, char etc) of the variable.
From the call to \verb!GetRhsVar! we know that \verb!A! has
\verb!m1! rows and \verb!n1! columns. 


\noindent
The line
\begin{verbatim}
if (n1 !=m2 ) 
     {Scierror(999,"%s: Uncompatible dimensions\r\n",fname);
                 return 0;}
\end{verbatim}
\normalsize
is to make a return to Scilab if the matrices \verb!A! and \verb!B! 
passed to \verb!matmul! have uncompatible dimensions. The number
of columns of \verb!A! should be equal to the number of rows of \verb!B!.

\noindent
The next step is to create the output variable \verb!C!. This is done by
\begin{verbatim}
CreateVar(3, "d", &m1, &n2, &l3);
\end{verbatim}
Here we create a variable numbered \verb!3! (\verb!1! was for \verb!A!
and \verb!2! was for \verb!B!). It is an array of double (\verb!"d"!).
It has \verb!m1! rows and \verb!n2! columns. 
The calling sequence of \verb!CreateVar! is the same as the calling sequence
of \verb!GetRhsVar!, but the four first parameters of \verb!CreateVar! 
are inputs. 

The next step is the call to \verb!matmul!. Remember the calling sequence~:
\begin{verbatim}
void matmul(a,n,m,b,l,c)
double a[],b[],c[]; int n,m,l;
\end{verbatim}
\noindent
We must send to this function (double) pointers to the numeric
data in \verb!A!, \verb!B! and \verb!C!.
This is done by~:
\begin{verbatim}
  matmul(stk(l1), m1, n1, stk(l2), n2, stk(l3));
\end{verbatim}
Here \verb!stk(l1)! is a double pointer to the content of the \verb!A!
matrix. The entries of the \verb!A! matrix are stored columnwise
in \verb!stk(l1)[0]!, \verb!stk(l1)[1]! etc.
Similarly, after the call to the C function \verb!matmul! the (double) numbers
\verb!stk(l3)[0]!, \verb!stk(l3)[1]! are the values of the 
matrix product \verb!A*B! stored columnwise as computed by
\verb!matmul!.
The last parameter of the functions \verb!GetRhsVar! and \verb!CreateVar!
is an output parameter which allow to access the data through a 
pointer (here the double pointers \verb!stk(l1)!, \verb!stk(l2)! and
\verb!stk(l3)!.

The final step is to return the result, i.e. the \verb!C! matrix to Scilab.
This is done by
\begin{verbatim}
  LhsVar(1) = 3;
\end{verbatim}
\noindent This statement means that the first LHS variable of 
the Scilab function \verb!matmul! is the variable numbered \verb!3!.

Once the gateway routine is written, it should be compiled, linked
with Scilab and a script file should be executed in Scilab
for loading the new function.

It is possible to build a static or a dynamic library.  The static library
corresponding the the example just described here is built in the directory
\verb!SCIDIR/examples/interface-tutorial! and the dynamic library is built 
into the directory \verb!SCIDIR/examples/interface-tutorial-so!.
\subsubsection{Static library}
In the directory \verb!SCIDIR/examples/interface-tutorial! just 
enter the \verb!make! command in an Unix platform or in the Windows
environment with the Visual C++ environment enter \verb!nmake /f Makefile.mak!.
This command produces the following file \verb!tutorial_gateway.c! which is
a C function produced by the Makefile~:

\scriptsize
\begin{verbatim}
#include "mex.h" 
extern Gatefunc intview;
extern Gatefunc intmatmul;
 
static GenericTable Tab[]={
{(Myinterfun)sci_gateway, intview,"error msg"},
{(Myinterfun)sci_gateway, intmatmul,"error msg"},
         };

int C2F(tutorial_gateway)()
{  Rhs = Max(0, Rhs);
(*(Tab[Fin-1].f))(Tab[Fin-1].name,Tab[Fin-1].F);
  return 0;
}
\end{verbatim}
\normalsize
\noindent
This function is essentially the table of C functions which 
are dynamically linked wih Scilab.

The following file \verb!tutorial.sce! is also produced by the Makefile~:
\scriptsize
\begin{verbatim}
scilab_functions =[...
"view";
"matmul";
           ];
auxiliary="";
files=G_make(["tutorial_gateway.o","tutorial.a", auxiliary],"void(Win)");
addinter(files,"tutorial_gateway",scilab_functions);
\end{verbatim}
\normalsize

The Scilab function \verb!addinter! makes the correspondance between the
C gateway functions (such as \verb!intmatmul!) and their names as Scilab
functions.

To load the newly created function \verb!matmul!, one has to execute this
script and then the function \verb!matmul! can be called into Scilab 
\begin{verbatim}
-->exec tutorial.sce

-->A=rand(2,3);B=rand(3,3);C=matmul(A,B);   //C=A*B
\end{verbatim}

Summing up, to build an static interface, the user has to write 
a gateway function such as \verb!intmatmul!. Then he has to edit 
the Makefile in
\verb!SCIDIR/examples/interface-tutorial! (or a copy of it) and to put there
the name of his gateway function(s) (e.g. \verb!intmatmul.o!) in the 
target \verb!CINTERFACE! and the name of the corresponding Scilab
function (e.g. \verb!matmul!) in the target \verb!CFUNCTIONS!
with the same ordering. Typing \verb!make! produces the static library
and a script file (here \verb!tutorial.sce!) which should be 
executed each time the newly created function(s) are needed. Of course,
it is possible to perform this operation automatically 
when Scilab is launched by creating a startup file \verb!.scilab! identical
to \verb!tutorial.sce!.

\subsubsection{Dynamic library}
The directory \verb!SCIDIR/examples/interface-tutorial-so! contains the 
material necessary to create a dynamic library (or a dll in the Windows environment) that can be dynamically linked with Scilab. 
This directory contains the following file called \verb!builder.sce!~:
\scriptsize
\begin{verbatim}
// This is the builder.sce 
// must be run from this directory 

ilib_name  = "libtutorial"           // interface library name 
files = ["intview.o","intmatmul.o"]  // objects files 
                                     // 
libs  = []                           // other libs needed for linking
table = [ "view", "intview";         // table of (scilab_name,interface-name)
          "matmul","intmatmul"];     //

// do not modify below 
// ----------------------------------------------
ilib_build(ilib_name,table,files,libs)
\end{verbatim}
\normalsize
The user should edit this file, which is a Scilab script, and 
in particular the variables \verb!files! (a row vector of strings)
anf \verb!table! a two column matrix of strings. 
\verb!files! should contain the names of all the object files 
(gateway functions and C functions called). 
Each row of \verb!table! is a pair of two strings: the first is the
name of the Scilab function, and the second the name of the 
gateway function. Here we have two functions \verb!view! which has
\verb!intview! as gateway and \verb!matmul! which has \verb!intmatmul!
as gateway. This is the example given above.
After the file \verb!builder.sce! has been edited, it should be 
executed in Scilab by the command
\begin{verbatim}
-->exec builder.sce
\end{verbatim}
Scilab then generates the file \verb!loader.sce!~:
\begin{verbatim}
// generated by builder.sce
libtutorial_path=get_file_path('loader.sce');
functions=[ 'view';
            'matmul';
];
addinter(libtutorial_path+'/libtutorial.so','libtutorial',functions);
\end{verbatim}
This file should be executed in Scilab to load the newly created function 
\verb!matmul!
\begin{verbatim}
-->exec loader.sce

-->A=rand(2,3);B=rand(3,3);C=matmul(A,B);   //C=A*B
\end{verbatim}
Summing up, to build a dynamic interface the user has to write a
gateway function (such as \verb!intmatmul!), then he has to edit
the file \verb!builder.sce! (or a copy of it) to enter
the name of the Scilab function and the necessary C functions, 
then he has to execute the script \verb!builder.sce!. This
produce the dynamic library and the script \verb!loader.sce!.
Then each time he needs the newly created function(s), he has to 
execute the script \verb!loader.sce!. 

\subsection{Functions used for building an interface}
The functions used to build an interface are Fortran subroutines when 
the interface is written in Fortran and are coded as C macros 
(defined in {\tt  stack-c.h} ) 
when the interface is coded in C. The main functions are as follows:

\begin{itemize}
\item{
\begin{verbatim}
CheckRhs(minrhs, maxrhs)
CheckLhs(minlhs, maxlhs)
\end{verbatim}
Function \verb!CheckRhs! is used to check that the Scilab function is called
with \\
{\verb! minrhs <= Rhs <= maxrhs!}. 
Function \verb!CheckLhs! is used to check that the expected return
values are in the range 
{\verb! minlhs <= Lhs <= maxlhs!}. (Usually one has {\tt minlhs=1}
since a Scilab function can be always be called with less lhs
arguments than expected).
}
\item{
\begin{verbatim}
GetRhsVar(k,ct,&mk,&nk,&lk)
\end{verbatim}
Note that \verb!k! (integer) and \verb!ct! (string) are inputs and 
\verb!mk,nk! and \verb!lk! (integers) are outputs of \verb!GetRhsVar!.
This function defines the type (\verb!ct!) of input variable numbered
\verb!k!, i.e. the \verb!k!th input variable in the calling sequence of the 
Scilab function. The pair \verb!mk,nk! gives the dimensions (number of rows
and columns)  of variable numbered \verb!k! if it is a matrix. 
If it is a chain \verb!mk*nk! is its length. \verb!lk! is the adress
of variable numbered \verb!k! in Scilab internal stack.
The type of variable number \verb!k!, \verb!ct!, should be set 
to {\tt "d", "r", "i" ,"z"} or {\tt "c"} which stands for double, float
(real), integer, double complex 
or character respectively. The interface should call function
\verb!GetRhsVar! for each of the rhs variables of the Scilab function
with {\tt k=1, k=2,..., k=Rhs}.
Note that if the Scilab argument doesn't match the requested type then 
Scilab enters an error function and returns from the interface function.
}
\item{
\begin{verbatim}
CreateVar(k,ct,&mk,&nk,&lk)
\end{verbatim}
Here \verb!k,ct,&mk,&nk! are inputs of \verb!CreateVar! and \verb!lk! is an
output of \verb!CreateVar!. The parameters are as above. Variable numbered
\verb!k! is created in Scilab internal stack at adress {\tt lk}. When
calling {\tt CreateVar}, {\tt k} must be greater than {\tt Rhs} i.e.
{\tt k=Rhs+1, k=Rhs+2, ...}.
If due to memory lack, the argument can't be created, then a Scilab error 
function is called and the interface function returns.
}
\item{
\begin{verbatim}
CreateVarFromPtr(k,ct,&mk,&nk,&lk)
\end{verbatim}
Here \verb!k,ct,&mk,&nk,&lk! are all inputs of \verb!CreateVarFromPtr! and
\verb!lk! is pointer created by a call to a C function. This function is used 
when a C object was created inside the interfaced function and a Scilab 
object is to be created using a pointer to this C object. }
\end{itemize}


Once the  variables have been processed by {\tt GetRhsVar} or created
by {\tt CreateVar}, they are given values by calling one or several 
numerical routine. The call to the numerical routine is done
in such a way that each argument of the routine points to the
corresponding Scilab variable. 
Character, integer, real, double and double complex type variables are 
respectively in the {\tt cstk}, {\tt istk}, {\tt sstk}, 
{\tt stk}, {\tt zstk} Scilab internal stack
at the adresses {\tt lk}'s returned by {\tt GetRhsVar} or {\tt CreateVar}. 

Then they are returned to Scilab as lhs variables.
The interface should define how the lhs (output) variables are
numbered. This is done by the global variable {\tt LhsVar}.
For instance
\begin{verbatim}
  LhsVar(1) = 5;
  LhsVar(2) = 3;
  LhsVar(3) = 1;
  LhsVar(4) = 2;
\end{verbatim}
means that the Scilab function has at most 4 output parameters
which are variables numbered \verb!k= 5, k=3, k=1, k=2! respectively.

The functions \verb!sciprint(amessage)! and \verb!Error(k)! are used
for managing messages and errors.

Other useful functions which can be used are the following.
\begin{itemize}
\item{
\begin{verbatim}
GetMatrixptr("Aname", &m, &n, &lp);
\end{verbatim}
This function reads a matrix in Scilab internal stack. \verb!Aname! is
a character string, name of a Scilab matrix. Outputs are integers
\verb!m,n! and \verb!lp!, the entries of the matrix are 
ordered {\em columnwise}.}
\item{
\begin{verbatim}
ReadString("Aname",&n,str)
\end{verbatim}
This function reads a string in Scilab internal stack. \verb!n! is the
length of the string.
}
\end{itemize}


The Fortran functions have the same syntax and return logical values.
\subsection{Examples}
There are many examples of external functions interfaced with Scilab in
the directories \verb!SCIDIR/examples/interface-tour! and \newline
\verb!SCIDIR/examples/interface-tour-so!. 
Examples are given in C and Fortran. 
The best way to build an interface is to copy one of the examples
given there and to adapt the code to particular needs.


\subsection{The {\tt addinter} command}
Once the interface program is written, it must be compiled to produce 
an object file. It is then linked to Scilab by the addinter command.

The syntax of addinter is the following:

{\tt addinter([`interface.o', 'userfiles.o'],'entrypt',['scifcts'])}

Here {\tt interface.o} is the object file of the interface, 
{\tt userfiles.o} is the set of user's routines to be linked, 
{\tt entrypt} is the entry point of the interface routine and 
{'scifcts'} is the set of Scilab functions to be interfaced.

\section{Intersci}
The directory \verb!SCIDIR/examples/intersci-examples-so! contains
several examples for using \verb!intersci! which is a tool for
producing gateway routines from a descriptor file.
Let us describe a simple example, \verb!ex01!.
We want to build an interface for the following C function~:
\begin{verbatim}
int ext1c(n, a, b, c)
     int *n;
     double *a, *b, *c;
{   
  int k;
  for (k = 0; k < *n; ++k) 
      c[k] = a[k] + b[k];
  return(0);
}
\end{verbatim}
This function just adds the two real vectors \verb!a! and \verb!b! 
with \verb!n! entries and returns the result in \verb!c!.
We want to have in Scilab a function \verb!c=ext1c(a,b)! which
performs this operation by calling  \verb!ext1c!.
For that, we provide a \verb!.desc! file, \verb!ex01fi.desc!~:
\begin{verbatim}
ext1c	a b 
a 	vector	m
b 	vector	m
c	vector  m 

ext1c   m a b c 
m	integer 
a	double 
b	double 
c	double 

out	sequence	c
***********************
\end{verbatim}
\noindent
This file in divided into three parts separated by a blank line. 
The upper part (four first lines) describes the Scilab function 
\verb!c=ext1c(a,b)!.
Then (next five lines) the C function is described. The last line of 
\verb!ex01fi.desc! gives the name of output variables. 
To run \verb!intersci! with this file as input we enter the command~:
\begin{verbatim}
SCIDIR/bin/intersci-n ex01fi
\end{verbatim}
Two files are created~: \verb!ex01fi.c! and \verb!ex01fi_builder.sce!.
The file \verb!ex01fi.c! is the C gateway function needed for interfacing
\verb!ext1c! with Scilab. It is a gateway file built as explained above 
(see \ref{interface})~:

\scriptsize
\begin{verbatim}
#include "stack-c.h"

int intsext1c(fname)
   char *fname;
{
 int m1,n1,l1,mn1,m2,n2,l2,mn2,un=1,mn3,l3;
 CheckRhs(2,2);
 CheckLhs(1,1);
 /*  checking variable a */
 GetRhsVar(1,"d",&m1,&n1,&l1);
 CheckVector(1,m1,n1);
 mn1=m1*n1;
 /*  checking variable b */
 GetRhsVar(2,"d",&m2,&n2,&l2);
 CheckVector(2,m2,n2);
 mn2=m2*n2;
 /* cross variable size checking */
 CheckDimProp(1,2,m1*n1 != m2*n2);
 CreateVar(3,"d",(un=1,&un),(mn3=mn1,&mn3),&l3);/* named: c */
 C2F(ext1c)(&mn1,stk(l1),stk(l2),stk(l3));
 LhsVar(1)= 3;
 return 0;
}
\end{verbatim}
\normalsize

The file \verb!ex01fi_builder.sce! is the following~:
\begin{verbatim}
// generated with intersci 
ilib_name = 'libex01fi'		// interface library name

table =["ext1c","intsext1c"];
ilib_build(ilib_name,table,files,libs);
\end{verbatim}

This  builder file is to be executed 
by Scilab after the variables \verb!files! and \verb!libs! have been set~:
\begin{verbatim}
-->files = ['ex01fi.o' , 'ex01c.o'];
-->libs  = [] ;
-->exec ex01fi_builder.sce
\end{verbatim}

\noindent
A dynamic library is then created as well as a file \verb!loader.sce!. 
Executing \verb!loader.sce! loads the library into Scilab and executes the
\verb!addinter! command to link the library and associate the name
of the function \verb!ext1c! to it. We can then call the new function~;
\begin{verbatim}
-->exec loader.sce
-->a=[1,2,3];b=[4,5,6]; c=ext1c(a,b);
\end{verbatim}

\noindent
To use \verb!intersci! one has to construct a \verb!.desc! file.
The keywords which describe the Scilab function and the function
to be called can be found in the examples given.

\section{Argument functions}
Some built-in nonlinear solvers, such as {\tt ode} or {\tt optim}, require a 
specific function as argument. For instance in the Scilab command
{\tt ode(x0,t0,t,fydot)}, {\tt fydot} is the specific argument function
for the {\tt ode} primitive.
This function can be a either Scilab function or an external
function written in C or Fortran.
In both cases, the argument function must obey a specific
syntax. In the following we will consider, as running example, using 
the {\tt ode} primitive with a rhs function written in Fortran. The
same steps should be followed for all primitives which require
a function as argument.

If the argument function is written in C or Fortran, there
are two ways to call it:
\begin{itemize}
\item -Use dynamic link
\begin{verbatim}
-->link('myfydot.o','myfydot')  
//or -->link('myfydot.o','myfydot','C')
-->ode(x0,t0,t,'myfydot')
\end{verbatim}
\item -Use the {\tt Ex-ode.f} interface in the {\tt routines/default}
directory (and {\tt make all} in Scilab directory).
The call to the {\tt ode} function is as above:
\begin{verbatim}
-->ode(x0,t0,t,'myfydot')
\end{verbatim}
\end{itemize}
In this latter case, to add a new function, two files should be updated:
\begin{itemize}
\item The {\tt Flist} file: Flist is list of entry points. Just add the 
name of your function at in the appropriate list of functions.
\begin{verbatim}
ode_list= ... myfydot
\end{verbatim}
\item The {\tt Ex-ode.f} (or {\tt Ex-ode-more.f}) file: this file contains the 
source code for argument functions. Add your function here.
\end{itemize}

Many exemples are provided in the {\tt default} directory.
More complex examples are also given. For instance it is shown 
how to use Scilab variables as optional parameters of {\tt fydot}.
\section{Mexfiles}
The directories under \verb!SCIDIR/examples/mexfiles! contain 
some examples of Matlab mexfiles which can be used as interfaces
in the Scilab environment. The Scilab \verb!mexlib! library emulates
the most commonly used Matlab \verb!mxfunctions! such as 
\verb!mxGetM!, \verb!mxGetPr!, \verb!mxGetIr! etc. Not all the 
\verb!mxfunctions! are available but standard mexfiles which make use
of matrices (possibly sparse), character strings and n-dimensional arrays 
can be used without any modification in the Scilab environment.
 
\section{Maple to Scilab Interface}
To combine symbolic computation of the computer algebra system Maple with the 
numerical facilities
of Scilab, Maple objects can be transformed into Scilab functions. To assure 
efficient numerical evaluation this is done through numerical evaluation in 
Fortran. The whole process is done by a Maple procedure called 
\verb/maple2scilab/.
\section{Maple2scilab}
\index{maple2scilab@{\tt maple2scilab}}
The procedure \verb!maple2scilab! converts a Maple object, 
either a scalar function or a matrix into a Fortran subroutine 
and writes the associated Scilab function. The code of \verb!maple2scilab!
is in the directory \verb!SCIDIR/maple!.

The calling sequence of \verb!maple2scilab! is as follows:\\
\verb!maple2scilab(function-name,object,args)!
\begin{itemize}
\item
The first argument, \verb!function-name! is a name indicating the 
function-name in Scilab.
\item
The second argument \verb!object! is the Maple name of the expression 
to be transferred to Scilab.
\item
The third argument is a list of arguments containing the formal parameters of
the Maple-object \verb!object!.
\end{itemize}
When \verb!maple2scilab! is invoked in Maple, two files are generated,
one which contains the Fortran code and another which contains the 
associated Scilab function. Aside their existence, the user has not to
know about their contents.

The Fortran routine which is generated has the following calling sequence:\\
{\tt <Scilab-name>(x1,x2,\ldots,xn,matrix)} \\
and this subroutine computes matrix(i,j) as a function of
the arguments {\tt x1,x2,\ldots,xn}.
Each argument can be a Maple scalar or array which should be
in the argument list. 
The Fortran subroutine is put into a file named {\tt <Scilab-name>.f}, the
Scilab-function into a file named {\tt <Scilab-name>.sci}.
For numerical evaluation in Scilab the user has to compile the Fortran 
subroutine, to link it with Scilab (e.g. Menu-bar option '\verb!link!')
and to load the associated function (Menu-bar option '\verb!getf!').
Information about \verb!link! operation is given in Scilab's manual: 
Fortran routines can be incorporated into Scilab by dynamic
link or through the \verb!Ex-fort.f! file in the \verb!default! directory.
 Of course, this two-step procedure can be automatized using a shell-script 
(or using \verb!unix! in Scilab).
Maple2scilab uses the ``Macrofort'' library which is in the share 
library of Maple.
\subsection{Simple Scalar Example}
\paragraph{Maple-Session}
\begin{verbatim}
> read(`maple2scilab.maple`):
> f:=b+a*sin(x);

                               f := b + a sin(x)

> maple2scilab('f_m',f,[x,a,b]);
\end{verbatim}
Here the Maple variable \verb!f! is a scalar expression but it could be also
a Maple vector or matrix.
\verb/ 'f_m'/ will be the name of \verb!f! in Scilab 
(note that the Scilab name is restricted to contain at most 6 characters).
The procedure \verb/maple2scilab/ creates two files: \verb/f_m.f/ 
and  \verb/f_m.sci/ in the directory where Maple is started.
To specify another directory just define in Maple the path : 
\verb/rpath:=`//\verb/work//` ; then all files are written in 
the sub-directory \verb/work/.
The file \verb!f_m.f! contains the source code of a stand alone Fortran
routine which is dynamically linked to Scilab by the function \verb!f_m! in
defined in the file \verb!f_m.sci!.

\paragraph{Scilab Session}
\begin{verbatim}
-->unix('make f_m.o');
 
-->link('f_m.o','f_m');

linking  _f_m_ defined in f_m.o  
 
-->getf('f_m.sci','c')
 
-->f_m(%pi,1,2)
 ans       =
 
    2.  
\end{verbatim}

\subsection{Matrix Example}
This is an example of transferring a Maple matrix into Scilab.
\paragraph{Maple Session}
\begin{verbatim}
> with(linalg):read(`maple2scilab.maple`):

> x:=vector(2):par:=vector(2):

> mat:=matrix(2,2,[x[1]^2+par[1],x[1]*x[2],par[2],x[2]]);

                            [     2                     ]
                            [ x[1]  + par[1]  x[1] x[2] ]
                    mat :=  [                           ]
                            [     par[2]         x[2]   ]

> maple2scilab('mat',mat,[x,par]);

\end{verbatim}

\paragraph{Scilab Session}
\begin{verbatim}
-->unix('make mat.o');

-->link('mat.o','mat') 

linking  _mat_ defined in mat.o  
 
-->getf('mat.sci','c')

-->par=[50;60];x=[1;2];
 
-->mat(x,par)
 ans       =
 
!   51.    2. !
!   60.    2. !
 
\end{verbatim}

{\small
\paragraph{Generated code}
Below is the code (Fortran subroutines and Scilab functions) which is 
automatically generated by {\tt maple2scilab} in the two preceding  examples.
\paragraph{Fortran routines}
\begin{verbatim}
c      
c     SUBROUTINE f_m
c      
      subroutine f_m(x,a,b,fmat)
      doubleprecision x,a,b
      implicit doubleprecision (t)
      doubleprecision fmat(1,1)
         fmat(1,1) = b+a*sin(x)
      end
\end{verbatim}
\begin{verbatim}
c      
c     SUBROUTINE mat
c      
      subroutine mat(x,par,fmat)
      doubleprecision x,par(2)
      implicit doubleprecision (t)
      doubleprecision fmat(2,2)
         t2 = x(1)**2
         fmat(2,2) = x(2)
         fmat(2,1) = par(2)
         fmat(1,2) = x(1)*x(2)
         fmat(1,1) = t2+par(1)
      end
\end{verbatim}
\paragraph{Scilab functions}
\begin{verbatim}
function [var]=f_m(x,a,b)
var=call('f_m',x,1,'d',a,2,'d',b,3,'d','out',[1,1],4,'d')
\end{verbatim}
\begin{verbatim}
function [var]=fmat(x,par)
var=call('fmat',x,1,'d',par,2,'d','out',[2,2],3,'d')
\end{verbatim}
}
%\end{document}



