<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "manrev.dtd">

<MAN>

  <LANGUAGE>eng</LANGUAGE>
  <TITLE>umf_luget  </TITLE>
  <TYPE>scilab function - scispt toolbox</TYPE>
  <DATE></DATE>
  <SHORT_DESCRIPTION name="umf_luget"> retrieve lu factors at the scilab level  </SHORT_DESCRIPTION>

  <CALLING_SEQUENCE>
      <CALLING_SEQUENCE_ITEM>[L,U,p,q,Rd] = umf_luget(LU_ptr)  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  
  <PARAM>
     <PARAM_INDENT>
     <PARAM_ITEM>
        <PARAM_NAME>LU_ptr  </PARAM_NAME>
        <PARAM_DESCRIPTION>
           : a pointer to umf lu factors (L,U,p,q,R)
	</PARAM_DESCRIPTION> 
     </PARAM_ITEM>
     <PARAM_ITEM>
        <PARAM_NAME>L,U  </PARAM_NAME>
        <PARAM_DESCRIPTION>
           : scilab sparse matrix
        </PARAM_DESCRIPTION> 
     </PARAM_ITEM>
     <PARAM_ITEM>
        <PARAM_NAME>p,q  </PARAM_NAME>
        <PARAM_DESCRIPTION>
           : column vectors storing the permutations
        </PARAM_DESCRIPTION> 
     </PARAM_ITEM>
     <PARAM_ITEM>
        <PARAM_NAME>Rd </PARAM_NAME>
        <PARAM_DESCRIPTION>
           : vector storing the (row) scaling factors
        </PARAM_DESCRIPTION> 
     </PARAM_ITEM>
     </PARAM_INDENT>
  </PARAM>

  <DESCRIPTION>
  <P>
    This function  may be used if you want  to plot  the sparse
    pattern  of the lu factors (or if you  code something which
    use the lu factors). The factorization provided by umfpack is
    of the form:
  </P> 
  <P>
       P R^(-1) A Q = LU
  </P> 
  <P>
    where P and Q are permutation matrices, R is a diagonal matrix (row scaling), L
    a lower triangular matrix with a diagonal of 1, and U an upper triangular matrix.
    The function provides the matrices L and U as Sparse scilab matrices but
    P and Q are given as permutation vectors p and q (in fact p is the permutation 
    associated to P&apos;) and Rd is the vector corresponding to the diagonal
    of R.
  </P>
  </DESCRIPTION>

  <EXAMPLE><![CDATA[
// this is the test matrix from UMFPACK
A = sparse( [ 2  3  0  0  0;
              3  0  4  0  6; 
              0 -1 -3  2  0; 
              0  0  1  0  0; 
              0  4  2  0  1] );
Lup = umf_lufact(A);
[L,U,p,q,R] = umf_luget(Lup);
B = A;
for i=1:5, B(i,:) = B(i,:)/R(i); end // apply the row scaling
B(p,q) - L*U  // must be a (quasi) nul matrix

umf_ludel(Lup) // clear memory

// the same with a complex matrix
A = sparse( [ 2+%i  3+2*%i  0      0    0;
              3-%i  0       4+%i   0    6-3*%i; 
              0    -1+%i   -3+6*%i 2-%i 0; 
              0     0       1-5*%i 0    0; 
              0     4       2-%i   0    1] );
Lup = umf_lufact(A);
[L,U,p,q,R] = umf_luget(Lup);
B = A;
for i=1:5, B(i,:) = B(i,:)/R(i); end // apply the row scaling
B(p,q) - L*U  // must be a (quasi) nul matrix

umf_ludel(Lup) // clear memory

 ]]></EXAMPLE>

  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>umfpack</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_lufact</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_lusolve</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_ludel</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_luinfo</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>

  <AUTHORS>
      <AUTHORS_ITEM><EM>umfpack</EM> by Timothy A. Davis (see <LINK>umf_license</LINK>)</AUTHORS_ITEM>
      <AUTHORS_ITEM><EM>scilab interface</EM> by Bruno Pincon</AUTHORS_ITEM>
  </AUTHORS>

</MAN>
