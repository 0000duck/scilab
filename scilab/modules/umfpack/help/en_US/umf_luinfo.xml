<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "manrev.dtd">

<MAN>

  <LANGUAGE>eng</LANGUAGE>
  <TITLE>umf_luinfo  </TITLE>
  <TYPE>scilab function - scispt toolbox</TYPE>
  <DATE>  </DATE>
  <SHORT_DESCRIPTION name="  umf_luinfo ">  get information on LU factors  </SHORT_DESCRIPTION>

  <CALLING_SEQUENCE>
     <CALLING_SEQUENCE_ITEM>[OK, nrow, ncol, lnz, unz, udiag_nz, it] = umf_luinfo(LU_ptr)  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>

  <PARAM>
     <PARAM_INDENT>
     <PARAM_ITEM>
        <PARAM_NAME>LU_ptr  </PARAM_NAME>
        <PARAM_DESCRIPTION>
           : a pointer to umf lu factors (L,U,p,q, R)
        </PARAM_DESCRIPTION> 
     </PARAM_ITEM>
     <PARAM_ITEM>
        <PARAM_NAME>OK  </PARAM_NAME>
        <PARAM_DESCRIPTION>
           : a scalar boolean
        </PARAM_DESCRIPTION> 
     </PARAM_ITEM>
     <PARAM_ITEM>
        <PARAM_NAME>nrow, ncol, lnz, unz, udiag_nz, it</PARAM_NAME>
        <PARAM_DESCRIPTION>
           : scalars (integers)
        </PARAM_DESCRIPTION> 
     </PARAM_ITEM>
     </PARAM_INDENT>
  </PARAM>

  <DESCRIPTION>
  <P>
    This function may be used to know basic information about 
    LU factors created with umf_lufact :
  </P>
  <P>
    first <VERB>OK</VERB> is %t if <VERB>LU_ptr</VERB> is a valid pointer to an umfpack 
    LU numeric handle (and %f else)
  </P>
  <P>
    if <VERB>OK</VERB> is %t then: 
  </P>
    <ITEMIZE>
      <ITEM label="nrow, ncol">
        <SP>: are the matrix size (L is <TT>nrow x n</TT> and U is  <TT>n x ncol</TT>
              where <TT>n = min(nrow,ncol)</TT>
        </SP>
      </ITEM>
      <ITEM label="lnz, unz">
        <SP>: are the number of non zeros elements in L and in U;
        </SP>
      </ITEM>
      <ITEM label="udiag_nz">
        <SP>: are the number of non zeros elements on the diagonal of U; if the matrix
              is square (<TT>nrow = ncol = n)</TT> then it is not inversible if 
              udiag_nz &lt; n (more precisely it appears to be numericaly not
              inversible through the LU factorization).
        </SP>
      </ITEM>
      <ITEM label="it">
        <SP>: 0 if the factors are real and 1 if they are complex.
        </SP>
      </ITEM>
    </ITEMIZE>
    <P>
    if OK is %f then all the others outputs are set to the empty matrix [].
    </P>
  </DESCRIPTION>

  <EXAMPLE><![CDATA[
// this is the test matrix from UMFPACK
A = sparse( [ 2  3  0  0  0;
              3  0  4  0  6; 
              0 -1 -3  2  0; 
              0  0  1  0  0; 
              0  4  2  0  1] );
Lup = umf_lufact(A);
[OK, nrow, ncol, lnz, unz, udiag_nz, it] = umf_luinfo(Lup)  // OK must be %t, nrow=ncol = 5, 
[L,U,p,q,R] = umf_luget(Lup);
nnz(L)  // must be equal to lnz
nnz(U)  // must be equal to unz
umf_ludel(Lup) // clear memory
   ]]></EXAMPLE>

  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>umfpack</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_lufact</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_lusolve</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_ludel</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_luget</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>

  <AUTHORS>
      <AUTHORS_ITEM><EM>umfpack</EM> by Timothy A. Davis (see <LINK>umf_license</LINK>)</AUTHORS_ITEM>
      <AUTHORS_ITEM><EM>scilab interface</EM> by Bruno Pincon</AUTHORS_ITEM>
  </AUTHORS>

</MAN>
