<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "manrev.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>umf_lufact  </TITLE>
  <TYPE>scilab function - scispt toolbox</TYPE>
  <DATE></DATE>
  <SHORT_DESCRIPTION name="umf_lufact"> lu factorisation of a sparse matrix  </SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
  <CALLING_SEQUENCE_ITEM>LU_ptr = umf_lufact(A)  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>A  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : a sparse, real or complex, square or rectangular, matrix
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>LU_ptr  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : a pointer to umf lu factors (L,U,p,q,R)
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
  <P>
    This function computes a LU factorisation of the sparse matrix A 
    (<tt> P R^(-1) A Q = LU </tt>) and return at the scilab level, 
    a pointer (LU_ptr) to an handle of the LU factors (L,U,p,q,R) 
    (the memory used for them is &quot;outside&quot; scilab stack). 
  </P>
  <P>
    This function must be used in place of <LINK>umfpack</LINK> if you
    have multiple linear systems with the same matrix to solve when
    the rhs are not known at the same time (for instance A x1 = b1
    and A x2 = b2 but b2 depends on x1, etc...). 
  </P>
  <P>
    When such a 
    factorisation have been computed, a linear system must be solved
    with umf_lusolve (in general x = umf_lusolve(LU_ptr, b) but others
    options are possible, see <LINK>umf_lusolve</LINK>). To free the memory used
    by the LU factors, use umf_ludel(LU_ptr) (<LINK>umf_ludel</LINK>); to retrieve the LU 
    factors at the scilab level (for example to display their sparse 
    patterns), use <LINK>umf_luget</LINK> ; to get some informations (number of
    non zeros in L and U), use <LINK>umf_luinfo</LINK>. To compute an approximation
    of the condition number use <LINK>condestsp</LINK>.
  </P>
  </DESCRIPTION>

  <EXAMPLE><![CDATA[
// this is the small linear test system from UMFPACK
// whom solution must be [1;2;3;4;5]
A = sparse( [ 2  3  0  0  0;
              3  0  4  0  6; 
              0 -1 -3  2  0; 
              0  0  1  0  0; 
              0  4  2  0  1] );
b = [8 ; 45; -3; 3; 19];
Lup = umf_lufact(A);
x = umf_lusolve(Lup,b)

// solve now A'x=b
x = umf_lusolve(Lup,b,"A''x=b")
norm(A'*x - b)

// don't forget to clear memory with
umf_ludel(Lup)

// a real (but small)  example
// first load a sparse matrix
[A] = ReadHBSparse(DIR_SCISPT_DEM+"arc130.rua");
// compute the factorisation
Lup = umf_lufact(A); 
b = rand(size(A,1),1); // a random rhs
// use umf_lusolve for solving Ax=b
x = umf_lusolve(Lup,b);
norm(A*x - b)

// now the same thing with iterative refiment
x = umf_lusolve(Lup,b,"Ax=b",A);
norm(A*x - b)

// solve now the system A'x=b
x = umf_lusolve(Lup,b,"A''x=b");  // without refinement
norm(A'*x - b)
x = umf_lusolve(Lup,b,"A''x=b",A);  // with refinement
norm(A'*x - b)

// don't forget to clear memory
umf_ludel(Lup)
   ]]></EXAMPLE>

  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>umfpack</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_luget</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_lusolve</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_ludel</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>umf_luinfo</LINK> </SEE_ALSO_ITEM>     
    <SEE_ALSO_ITEM> <LINK>condestsp</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>
  <AUTHORS>
      <AUTHORS_ITEM><EM>umfpack</EM> by Timothy A. Davis (see <LINK>umf_license</LINK>)</AUTHORS_ITEM>
      <AUTHORS_ITEM><EM>scilab interface</EM> by Bruno Pincon with contributions from Antonio Frasson</AUTHORS_ITEM>
  </AUTHORS>
</MAN>
