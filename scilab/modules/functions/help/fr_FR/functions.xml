<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) ????-2008 - INRIA
 *
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:db="http://docbook.org/ns/docbook" version="5.0-subset Scilab" xml:lang="fr" xml:id="functions"><info><pubdate>$LastChangedDate$</pubdate></info><refnamediv><refname>functions</refname><refpurpose> procédures Scilab et objets Scilab  </refpurpose></refnamediv>
  
  
  
  
  
  <refsection><title>Description</title>
  <para>
    Les fonctions Scilab sont des procédures ("macros", "fonction" et "procédures"
    ont la même signification). 
  </para>
  <variablelist>
  <varlistentry><term>Définition de fonctions</term><listitem>

  <para>
    Les fonctions sont tapées dans un éditeur de texte et chargées dans Scilab avec la commande <literal>getf</literal> ou via une librairie (voir <literal>lib</literal> ou <literal>genlib</literal>). Mais elles peuvent être définies en ligne (voir <literal>deff</literal> ou <literal>function</literal>).  Une fonction est définie en deux parties :  
  </para>

<para>une ligne de déclaration formelle</para>


  <programlisting><![CDATA[
 function [y1,...,yn]=foo(x1,...,xm)
 function [y1,...,yn,varargout]=foo(x1,...,xm,varargin)
   ]]></programlisting>

<para>une suite d'instructions Scilab.</para>


  <para>
     La "ligne de définition" donne la syntaxe d'appel complète de la fonction. Les <literal>yi</literal> sont les variables de sortie, calculées à partir des variables d'entrée <literal>xi</literal> et des variables existantes dans le contexte appelant lorsque la fonction est exécutée. On peut utiliser éventuellement un sous-ensemble de ces variables d'entrée et de sortie.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>Appel à une fonction</term><listitem>
<para>
    LA syntaxe d'appel est habituellement <literal>[y1,...,yn]=foo(x1,...,xm)</literal>. On peut utiliser éventuellement un sous-ensemble de ces variables d'entrée et de sortie. Dans ce cas, seules les premières variables à partir de la gauche sont utilisées. La fonction <literal>argn</literal> peut être utilisée pour connaître le nombre effectif d'arguments d'appel.
  </para>
<para>
    Il est aussi possible d'utiliser des "arguments nommés" pour spécifier les valeurs des arguments d'entrée  : supposons que la fonction <literal>fun1</literal> est définie ainsi <literal>function y1=fun1(x1,x2,x3)</literal> alors on peut utiliser la syntaxe  <literal>y=fun1(x1=33,x3=[1 2 3])</literal>, et dans <literal>fun1</literal> x2 ne sera pas défini. Il est possible de vérifier quelles sont les variables définies avec la fonction <literal>exists</literal>.
  </para>
<para>
    Quand une fonction n'a pas d'argument de sortie et est appelée avec des arguments d'entrée de type chaîne de caractère, la syntaxe d'appel peut être simplifiée : <literal>fun('a','toto','une chaîne')</literal> est alors équivalent à <literal>fun a toto 'une chaîne'</literal> 
  </para>
  </listitem></varlistentry>
  <varlistentry><term>Divers</term><listitem>
  <para>
    Les fonctions sont des objets Scilab (numéro de type 13 ou 11). Elles peuvent être manipulées (passées en argument, sauvées, chargées, ...) comme toute autre variable.
  </para>
  <para>
    Un ensemble de fonctions peut être assemblé dans une librairie. Les fonctions dont le nom commence par le caractère <literal>%</literal> (exemple : <literal>%foo</literal>) sont utilisées pour la surcharge des opérateurs (voir <literal>overloading</literal>) ou des fonctions pour des nouveaux types de données.
  </para>
  </listitem></varlistentry>
  </variablelist>
 </refsection>
  <refsection><title>Exemples</title><programlisting role="example"><![CDATA[
// définition en ligne
function [x,y]=myfct(a,b)
x=a+b
y=a-b
endfunction

[x,y]=myfct(3,2)

// autre type de définition en ligne
deff('[x,y]=myfct(a,b)',['x=a+b';
                         'y=a-b'])
// définition dans un fichier texte (voir exec)
exec SCI/modules/elementary_functions/macros/asinh.sci;

// définition dans un fichier texte (voir getf)
getf SCI/modules/elementary_functions/macros/asinh.sci;

 ]]></programlisting></refsection>
  <refsection><title>Voir Aussi</title><simplelist type="inline">
    <member> <link linkend="function">function</link> </member>     <member> <link linkend="deff">deff</link> </member>     <member> <link linkend="getf">getf</link> </member>     <member> <link linkend="comp">comp</link> </member>     <member> <link linkend="lib">lib</link> </member>     <member> <link linkend="getd">getd</link> </member>     <member> <link linkend="genlib">genlib</link> </member>     <member> <link linkend="exists">exists</link> </member>     <member> <link linkend="varargin">varargin</link> </member>     <member> <link linkend="varargout">varargout</link> </member>
  </simplelist></refsection>
</refentry>