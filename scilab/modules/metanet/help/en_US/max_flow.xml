<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE MAN SYSTEM "../../../../modules/helptools/help.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>max_flow</TITLE>
  <TYPE>Scilab function</TYPE>
  <DATE>$LastChangedDate$</DATE>
  <SHORT_DESCRIPTION name="max_flow"> maximum flow between two nodes</SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
    <CALLING_SEQUENCE_ITEM>[v,phi,flag] = max_flow(i,j,g)  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
        <PARAM_NAME>i</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: integer, number of start node</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>j</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: integer, number of end node</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>g</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: a <LINK>graph_data_structure</LINK>.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>v</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: value of the maximum flow it is exists</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>phi</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: row vector of the value of the flow on the arcs</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>flag</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: feasible problem flag (0 or 1)</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
    <P><VERB>max_flow</VERB> returns the value of maximum flow <VERB>v</VERB> from node number
    <VERB>i</VERB> to node number <VERB>j</VERB> if it exists, and the value of the flow 
    on each arc as a row vector <VERB>phi</VERB>. All the computations are made with 
    integer numbers. The graph must be directed. If the problem is not 
    feasible, <VERB>flag</VERB> is equal to 0, otherwise it is equal to 1.</P>
    <P>
    The bounds of the flow are given by the
    <VERB>min_cap</VERB> and <VERB>max_cap</VERB> fields of the
    <LINK>edges_data_structure</LINK>.  The value of the maximum
    capacity must be greater than or equal to the value of the minimum
    capacity.  If the value of <VERB>min_cap</VERB> or
    <VERB>max_cap</VERB> is not given, they are assumed to be equal to
    0 on each edge.</P>
  </DESCRIPTION>
  <EXAMPLE>
<![CDATA[
ta=[1 1 2 2 3 3 4 4 5 5 5 5 6 6 6 7 7 15 15 15 15 15 15 15 8 9 10 11 12 13 14];
he=[10 13 9 14 8 11 9 11 8 10 12 13 8 9 12 8 11 1 2 3 4 5 6 7 16 16 16 16 16 16 16];
g=make_graph('foo',1,16,ta,he);
g.nodes.graphics.x=[53,430,202,374,116,250,325,176,373,34,330,233,114,429,208,206];
g.nodes.graphics.y=[86,114,115,129,118,122,133,222,222,221,214,219,218,246,40,301];
ma=edge_number(g);
g=add_edge_data(g,'max_cap',[2,4,3,3,3,2,3,3,5,2,3,1,2,1,4,1,2,2,2,2,4,1,5,3,2,1,5,4,3,4,2]);
g=add_edge_data(g,'min_cap',ones(1,ma))
source=15;g.nodes.graphics.type(source)=2; //source node
sink=16;g.nodes.graphics.type(sink)=1; //sink node
show_graph(g);

[v,phi,ierr]=max_flow(source,sink,g);
g.edges.graphics.foreground(ii)=11;
g=add_edge_data(g,'flow',phi)
g.edges.graphics.display='flow';
show_graph(g);
 ]]>
  </EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM>
      <LINK>min_lcost_flow1</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>min_lcost_flow2</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>min_qcost_flow</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>edges_data_structure</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>add_edge_data</LINK>
    </SEE_ALSO_ITEM>
  </SEE_ALSO>

</MAN>
