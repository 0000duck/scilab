<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE MAN SYSTEM "../../manrev.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>knapsack</TITLE>
  <TYPE>Scilab function</TYPE>
  <DATE>$LastChangedDate$</DATE>
  <SHORT_DESCRIPTION name="knapsack"> solves a 0-1 multiple knapsack problem</SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
    <CALLING_SEQUENCE_ITEM>[earn,ind] = knapsack(profit,weight,capa,[bck])  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
        <PARAM_NAME>profit</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: integer row vector</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>weight</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: integer row vector</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>capa</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: integer row vector</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>bck</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: integer</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>earn</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: integer</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>ind</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: integer row vector</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
    <SP>The 0-1 multiple knapsack problem with  n (n &gt;= 2)
    items and  m  knapsacks (m &gt;= 1) is defined as follow:</SP>
    <P>Maximize the global profit  <VERB>E=profit*sum(X,1)</VERB> under the constraints:</P>
    <P><VERB>X*weight &lt;= capa</VERB></P>
    <P><VERB>sum(X,1) &lt;= 1 ; i=1,...,n</VERB></P>
    <P><VERB>X(j,i)= 0 or 1</VERB></P>
    <P> Where</P>
    <P><VERB>profit</VERB> is the vector of the profits of the n items. The entries must be positive integers.</P>
    <P><VERB>weight</VERB> is the vector of the corresponding weights. The entries must be positive integers</P>
    <P><VERB>capa</VERB> is the vector of the (integer) capacities of the m knapsacks.The entries must be positive integers </P> 
    <P><VERB>X</VERB> is a <VERB>m</VERB> by <VERB>n</VERB> matrix.</P>
    <P> </P>
    <P><VERB>[earn,ind] = knapsack(profit,weight,capa)</VERB> solves
    the problem. It returns in<VERB>earn</VERB> the value of the
    criterium <VERB>E</VERB> for the &quot;optimal&quot; solution. It
    also return in the vector <VERB>ind</VERB> the optimal locations:
    <VERB>ind(i)</VERB> gives the number of the knapsack where item i
    is inserted and this value is 0 if the item i is not in the
    optimal solution. The matrix <VERB>X</VERB> can be derived from
    <VERB>ind</VERB> by  </P>
    <VERBATIM>
      items=1:n;
      items(ind==0)==[];
      ind(ind==0)=[];
      X=sparse([ind;items]',ones(n,1),[m,n])
    </VERBATIM>
    <P></P>
    <P><VERB>bck</VERB> is an optional integer: the maximum number of
    backtrackings to be performed, if heuristic solution is
    required. If the exact solution is required <VERB>bck</VERB> can
    be omitted or can have a negative value.</P> 
 
  </DESCRIPTION>
  <EXAMPLE>
<![CDATA[
weight=ones(1,15).*.[1:4];
profit=ones(1,60);
capa=[15 40 30 60];
[earn,ind]=knapsack(profit,weight,capa)

items=1:60;
items(ind==0)=[];
ind(ind==0)=[];
X=full(sparse([ind;items]',ones(ind),[4,60])) //one row per sacks
X*weight' //sack weights
x=sum(X,1);
and(x<=1) //contraints check
profit*x'==earn
 ]]>
  </EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM>
      <LINK>qassign</LINK>
    </SEE_ALSO_ITEM>
  </SEE_ALSO>
<BIBLIO>
<P>Coppersmith, D. "Knapsack Used in Factoring." §4.6 in Open Problems in Communication and Computation (Ed. T. M. Cover and B. Gopinath). New York: Springer-Verlag, pp. 117-119, 1987.</P>
<P>Honsberger, R. Mathematical Gems III. Washington, DC: Math. Assoc. Amer., pp. 163-166, 1985.</P>
</BIBLIO>

</MAN>
