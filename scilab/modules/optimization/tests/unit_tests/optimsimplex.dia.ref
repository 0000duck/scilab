// =============================================================================
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) ????-2008 - INRIA - Michael Baudin
//
//  This file is distributed under the same license as the Scilab package.
// =============================================================================
utdir = SCI+"/modules/optimization/tests/unit_tests/optimsimplex"
 utdir  =
 
 SCI/modules/optimization/tests/unit_t 
      ests/optimsimplex                                                 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
 
//
 
// Test with a scalar length
 
//
 
myobj = tlist(["T_MYSTUFF","nb"]);
 
myobj.nb = 0;
 
function [ y , myobj ] = mycostf ( x , myobj )
  y = rosenbrock(x);
  myobj.nb = myobj.nb + 1
endfunction
 
s1 = optimsimplex_new ();
 
[ s1 , myobj ] = optimsimplex_axes ( s1 , x0 = [-1.2 1.0] , fun = mycostf , len = 1.0, data=myobj );
 
computed = optimsimplex_getall ( s1 );
 
expected = [
24.2 -1.2 1.0
93.6 -0.2 1.0
36.2 -1.2 2.0
];
 
assert_close ( computed , expected , %eps );
 
assert_equal ( myobj.nb , 3 );
 
nbve = optimsimplex_getnbve ( s1 );
 
assert_equal ( nbve , 3 );
 
s1 = optimsimplex_destroy ( s1 );
 
//
 
// Test with a vector length
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_axes ( s1 , x0 = [-1.2 1.0] , fun = rosenbrock , len = [1.0 2.0] );
 
computed = optimsimplex_getall ( s1 );
 
expected = [
24.2 -1.2 1.
93.6 -0.2 1.
248.2 -1.2 3.
];
 
assert_close ( computed , expected , %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
 
//
 
// Check behaviour with default settings.
 
//
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
coords = [...
0.0 3.0 0.0
0.0 0.0 6.0
];
 
s1 = optimsimplex_new ( coords );
 
sicenter = optimsimplex_center ( s1 );
 
assert_close ( sicenter , [1.0 2.0]', %eps );
 
s1 = optimsimplex_destroy(s1);
 
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
//
 
// Test optimsimplex_check.
 
//
 
//
 
// Test with 3 vertices
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn(s1,2);
 
s1 = optimsimplex_setnbve(s1,3);
 
newsimplex = [
1.0 3.0 5.0
2.0 4.0 6.0
];
 
s1 = optimsimplex_setallx ( s1 , newsimplex );
 
s1 = optimsimplex_setallfv ( s1 , [3.0 4.0 5.0]' );
 
optimsimplex_check ( s1 );
 
s1 = optimsimplex_destroy(s1);
 
//
 
// Test with empty simplex
 
//
 
s1 = optimsimplex_new ();
 
optimsimplex_check ( s1 );
 
s1 = optimsimplex_destroy(s1);
 
//
 
// Test with 3 vertices
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn(s1,2);
 
s1 = optimsimplex_setnbve(s1,5);
 
newsimplex = [
1.0 3.0 5.0 7.0 9.0
2.0 4.0 6.0 8.0 10.0
];
 
s1 = optimsimplex_setallx ( s1 , newsimplex );
 
s1 = optimsimplex_setallfv ( s1 , [3.0 4.0 5.0 6.0 7.0]' );
 
optimsimplex_check ( s1 );
 
s1 = optimsimplex_destroy(s1);
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
//
 
// Test optimsimplex_computefv
 
//
 
//
 
// Test with 3 vertices
 
//
 
s1 = optimsimplex_new ();
 
simplex = [
0.0 0.0 0.0
0.0 1.0 0.0
0.0 0.0 1.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
s1 = optimsimplex_computefv ( s1 , rosenbrock );
 
computed = optimsimplex_getall ( s1 );
 
// The function value at vertex #1 is re-computed, as expected.
 
expected = [
1.    0.   0.
100.   1.   0.
101. 0. 1.
];
 
assert_equal ( computed , expected );
 
s1 = optimsimplex_destroy ( s1 );
 
//
 
// Test with an additional argument
 
//
 
myobj = tlist(["T_MYSTUFF","nb"]);
 
myobj.nb = 0;
 
function [ y , myobj ] = mycostf ( x , myobj )
  y = rosenbrock(x);
  myobj.nb = myobj.nb + 1
endfunction
 
s1 = optimsimplex_new ();
 
simplex = [
0.0 0.0 0.0
0.0 1.0 0.0
0.0 0.0 1.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
[ s1 , myobj ] = optimsimplex_computefv ( s1 , mycostf , myobj );
 
computed = optimsimplex_getall ( s1 );
 
// The function value at vertex #1 is re-computed, as expected.
 
expected = [
    1.      0.    0.  
    100.    1.    0.  
    101.    0.    1.  
];
 
assert_equal ( computed , expected );
 
assert_equal ( myobj.nb , 3 );
 
s1 = optimsimplex_destroy ( s1 );
 
//
 
// Test with 5 vertices
 
//
 
s1 = optimsimplex_new ();
 
simplex = [
0.0 0.0 0.0
0.0 1.0 0.0
0.0 0.0 1.0
12.0 1.0 1.0
12.0 2.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
s1 = optimsimplex_computefv ( s1 , rosenbrock );
 
computed = optimsimplex_getall ( s1 );
 
// The function value at vertex #1 is re-computed, as expected.
 
expected = [
1.    0.   0.
100.   1.   0.
101. 0. 1.
0. 1. 1.
401. 2. 2.
];
 
assert_equal ( computed , expected );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// Test optimsimplex_deltafv
 
//
 
 
//
 
// Test with 3 vertices
 
//
 
s1 = optimsimplex_new ();
 
simplex = [
1. -2.0 1.0
4. -1.0 3.0
7. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
df = optimsimplex_deltafv ( s1 );
 
assert_close ( df , [3.0 6.0]' , %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
//
 
// Test with 5 vertices
 
//
 
s1 = optimsimplex_new ();
 
simplex = [
1. -2.0 1.0
4. -1.0 3.0
7. -3.0 2.0
9. -3.0 2.0
11. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
df = optimsimplex_deltafv ( s1 );
 
assert_close ( df , [3.0 6.0 8.0 10.0]' , %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
 
//
 
// optimsimplex_deltafvmax
 
//
 
 
//
 
// Test with 3 vertices
 
//
 
s1 = optimsimplex_new ();
 
simplex = [
1. -2.0 1.0
4. -1.0 3.0
7. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
dfm = optimsimplex_deltafvmax ( s1 );
 
assert_close ( dfm , 6.0 , %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
//
 
// Test with 5 vertices
 
//
 
s1 = optimsimplex_new ();
 
simplex = [
1. -2.0 1.0
4. -1.0 3.0
7. -3.0 2.0
9. -3.0 2.0
11. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
dfm = optimsimplex_deltafvmax ( s1 );
 
assert_close ( dfm , 10.0 , %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
 
// Test optimsimplex_dirmat
 
 
// Test with 3 vertices
 
s1 = optimsimplex_new ();
 
simplex = [
1. -2.0 1.0
4. -1.0 3.0
7. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
m = optimsimplex_dirmat ( s1 );
 
assert_close ( m , [1. -1.;2. 1.], %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
 
// Test with 5 vertices
 
s1 = optimsimplex_new ();
 
simplex = [
1. -2.0 1.0
4. -1.0 3.0
7. -3.0 2.0
9. -5.0 3.0
11. -7.0 4.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
m = optimsimplex_dirmat ( s1 );
 
assert_close ( m , [
1. -1. -3. -5.0 
2. 1. 2.0 3.0
], %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
 
// Test optimsimplex_fvmean
 
 
// Test with 3 vertices
 
s1 = optimsimplex_new ();
 
simplex = [
24. -2.0 1.0
93. -1.0 3.0
36. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
m = optimsimplex_fvmean ( s1 );
 
assert_close ( m , 51.0 , %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
 
// Test with 5 vertices
 
s1 = optimsimplex_new ();
 
simplex = [
24. -2.0 1.0
93. -1.0 3.0
36. -3.0 2.0
37. -3.0 2.0
38. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
m = optimsimplex_fvmean ( s1 );
 
assert_close ( m , 45.6 , %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
 
// Test optimsimplex_fvstdev with 3 vertices 
 
s1 = optimsimplex_new ();
 
simplex = [
1. -2.0 1.0
4. -1.0 3.0
7. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
sd = optimsimplex_fvstdev ( s1 );
 
assert_close ( sd , 3.0 , %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
 
// Test optimsimplex_fvstdev with 5 vertices 
 
s1 = optimsimplex_new ();
 
simplex = [
4. -2.0 1.0
4. -1.0 3.0
7. -3.0 2.0
10. -3.0 2.0
10. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
sd = optimsimplex_fvstdev ( s1 );
 
assert_close ( sd , 3.0 , %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
//
 
// Test optimsimplex_new, optimsimplex_destroy, optimsimplex_setn, optimsimplex_setx, optimsimplex_setfv,
 
// optimsimplex_getn, optimsimplex_getx, optimsimplex_getfv
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn(s1,2);
 
s1 = optimsimplex_setnbve(s1,3);
 
s1 = optimsimplex_setx(s1,1,[0.0 0.0]');
 
s1 = optimsimplex_setfv(s1,1,12.0);
 
s1 = optimsimplex_setx(s1,2,[1.0 0.0]');
 
s1 = optimsimplex_setfv(s1,2,13.0);
 
s1 = optimsimplex_setx(s1,3,[0.0 2.0]');
 
s1 = optimsimplex_setfv(s1,3,14.0);
 
// Now check the data
 
computed = optimsimplex_getn(s1);
 
assert_equal ( computed , 2 );
 
computed = optimsimplex_getx( s1 , 1);
 
assert_equal ( computed , [0.0 0.0]' );
 
computed = optimsimplex_getx( s1 , 2);
 
assert_equal ( computed , [1.0 0.0]' );
 
computed = optimsimplex_getx( s1 , 3);
 
assert_equal ( computed , [0.0 2.0]' );
 
computed = optimsimplex_getfv( s1 , 1);
 
assert_equal ( computed , 12.0 );
 
computed = optimsimplex_getfv( s1 , 2);
 
assert_equal ( computed , 13.0 );
 
computed = optimsimplex_getfv( s1 , 3);
 
assert_equal ( computed , 14.0 );
 
// Print the simplex
 
optimsimplex_print ( s1 );
Vertex #1/3 : fv=12.000000, x=0.000000 0.000000

Vertex #2/3 : fv=13.000000, x=1.000000 0.000000

Vertex #3/3 : fv=14.000000, x=0.000000 2.000000

 
// We are done !
 
s1 = optimsimplex_destroy(s1);
 
 
//
 
// Test optimsimplex_setallx, optimsimplex_setallfv, optimsimplex_getallx, optimsimplex_getallfv.
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn(s1,2);
 
s1 = optimsimplex_setnbve(s1,3);
 
s1 = optimsimplex_setx(s1,1,[0.0 0.0]');
 
s1 = optimsimplex_setfv(s1,1,12.0);
 
s1 = optimsimplex_setx(s1,2,[1.0 0.0]');
 
s1 = optimsimplex_setfv(s1,2,13.0);
 
s1 = optimsimplex_setx(s1,3,[0.0 2.0]');
 
s1 = optimsimplex_setfv(s1,3,14.0);
 
// Now check the data
 
computed = optimsimplex_getallx (s1);
 
expected = [
0.0 1.0 0.0
0.0 0.0 2.0
];
 
assert_equal ( computed , expected );
 
computed = optimsimplex_getallfv (s1);
 
assert_equal ( computed , [12.0 13.0 14.0]' );
 
// setallx, setallfv
 
newsimplex = [
1.0 3.0 5.0
2.0 4.0 6.0
];
 
s1 = optimsimplex_setallx ( s1 , newsimplex );
 
computed = optimsimplex_getallx (s1);
 
assert_equal ( computed , newsimplex );
 
s1 = optimsimplex_setallfv ( s1 , [3.0 4.0 5.0]' );
 
computed = optimsimplex_getallfv (s1);
 
assert_equal ( computed , [3.0 4.0 5.0]' );
 
s1 = optimsimplex_destroy(s1);
 
 
//
 
// Test optimsimplex_setve, optimsimplex_getve
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn ( s1 , 2 );
 
s1 = optimsimplex_setnbve(s1,3);
 
s1 = optimsimplex_setve ( s1 , 1 , 13.0 , [0.0 0.0]' );
 
s1 = optimsimplex_setve ( s1 , 2 , 14.0 , [1.0 0.0]' );
 
s1 = optimsimplex_setve ( s1 , 3 , 15.0 , [0.0 2.0]' );
 
computed = optimsimplex_getallx ( s1 );
 
expected = [
0.0 1.0 0.0
0.0 0.0 2.0
];
 
assert_equal ( computed , expected );
 
computed = optimsimplex_getallfv ( s1 );
 
assert_equal ( computed , [13.0 14.0 15.0]' );
 
ve1 = optimsimplex_getve ( s1 , 1 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [0.0 0.0]' );
 
assert_equal ( ve1.fv , 13.0 );
 
ve2 = optimsimplex_getve ( s1 , 2 );
 
assert_equal ( ve2.n , 2 );
 
assert_equal ( ve2.x , [1.0 0.0]' );
 
assert_equal ( ve2.fv , 14.0 );
 
ve3 = optimsimplex_getve ( s1 , 3 );
 
assert_equal ( ve3.n , 2 );
 
assert_equal ( ve3.x , [0.0 2.0]' );
 
assert_equal ( ve3.fv , 15.0 );
 
s1 = optimsimplex_destroy(s1);
 
//
 
// optimsimplex_getall, optimsimplex_setall
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn ( s1 , 2 );
 
s1 = optimsimplex_setnbve(s1,3);
 
s1 = optimsimplex_setve ( s1 , 1 , 13.0 , [0.0 0.0]' );
 
s1 = optimsimplex_setve ( s1 , 2 , 14.0 , [1.0 0.0]' );
 
s1 = optimsimplex_setve ( s1 , 3 , 15.0 , [0.0 2.0]' );
 
computed = optimsimplex_getall ( s1 );
 
expected = [
    13.    0.    0.  
    14.    1.    0.  
    15.    0.    2.  
];
 
assert_equal ( computed , expected );
 
simplex = [
10.0 1.0 2.0
11.0 3.0 4.0
12.0 5.0 6.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
ve1 = optimsimplex_getve ( s1 , 1 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [1.0 2.0]' );
 
assert_equal ( ve1.fv , 10.0 );
 
ve1 = optimsimplex_getve ( s1 , 2 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [3.0 4.0]' );
 
assert_equal ( ve1.fv , 11.0 );
 
ve1 = optimsimplex_getve ( s1 , 3 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [5.0 6.0]' );
 
assert_equal ( ve1.fv , 12.0 );
 
s1 = optimsimplex_destroy(s1);
 
//
 
// optimsimplex_getall, optimsimplex_setall with 5 vertices
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn ( s1 , 2 );
 
s1 = optimsimplex_setnbve(s1, 5 );
 
s1 = optimsimplex_setve ( s1 , 1 , 13.0 , [0.0 0.0]' );
 
s1 = optimsimplex_setve ( s1 , 2 , 14.0 , [1.0 0.0]' );
 
s1 = optimsimplex_setve ( s1 , 3 , 15.0 , [0.0 2.0]' );
 
s1 = optimsimplex_setve ( s1 , 4 , 16.0 , [1.0 3.0]' );
 
s1 = optimsimplex_setve ( s1 , 5 , 17.0 , [2.0 4.0]' );
 
computed = optimsimplex_getall ( s1 );
 
expected = [
    13.    0.    0.  
    14.    1.    0.  
    15.    0.    2.  
    16.    1.    3.  
    17.    2.    4.  
];
 
assert_equal ( computed , expected );
 
simplex = [
10.0 1.0 2.0
11.0 3.0 4.0
12.0 5.0 6.0
13.0 6.0 7.0
14.0 7.0 8.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
ve1 = optimsimplex_getve ( s1 , 1 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [1.0 2.0]' );
 
assert_equal ( ve1.fv , 10.0 );
 
ve1 = optimsimplex_getve ( s1 , 2 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [3.0 4.0]' );
 
assert_equal ( ve1.fv , 11.0 );
 
ve1 = optimsimplex_getve ( s1 , 3 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [5.0 6.0]' );
 
assert_equal ( ve1.fv , 12.0 );
 
ve1 = optimsimplex_getve ( s1 , 4 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [6.0 7.0]' );
 
assert_equal ( ve1.fv , 13.0 );
 
ve1 = optimsimplex_getve ( s1 , 5 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [7.0 8.0]' );
 
assert_equal ( ve1.fv , 14.0 );
 
s1 = optimsimplex_destroy(s1);
 
//
 
// Test optimsimplex_setallx, optimsimplex_setallfv, optimsimplex_getallx, optimsimplex_getallfv with 5 vertices
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn(s1,2);
 
s1 = optimsimplex_setnbve(s1,5);
 
s1 = optimsimplex_setx  ( s1 , 1 , [0.0 0.0]');
 
s1 = optimsimplex_setfv ( s1 , 1 , 12.0);
 
s1 = optimsimplex_setx  ( s1 , 2 , [1.0 0.0]');
 
s1 = optimsimplex_setfv ( s1 , 2 , 13.0);
 
s1 = optimsimplex_setx  ( s1 , 3 , [0.0 2.0]');
 
s1 = optimsimplex_setfv ( s1 , 3 , 14.0);
 
s1 = optimsimplex_setx  ( s1 , 4 , [1.0 3.0]');
 
s1 = optimsimplex_setfv ( s1 , 4 , 15.0);
 
s1 = optimsimplex_setx  ( s1 , 5 , [2.0 4.0]');
 
s1 = optimsimplex_setfv ( s1 , 5 , 16.0);
 
// Now check the data
 
computed = optimsimplex_getallx (s1);
 
expected = [
0.0 1.0 0.0 1.0 2.0
0.0 0.0 2.0 3.0 4.0
];
 
assert_equal ( computed , expected );
 
computed = optimsimplex_getallfv (s1);
 
assert_equal ( computed , [12.0 13.0 14.0 15.0 16.0]' );
 
// setallx, setallfv
 
newsimplex = [
1.0 3.0 5.0 7.0 9.0
2.0 4.0 6.0 8.0 10.0
];
 
s1 = optimsimplex_setallx ( s1 , newsimplex );
 
computed = optimsimplex_getallx (s1);
 
assert_equal ( computed , newsimplex );
 
s1 = optimsimplex_setallfv ( s1 , [3.0 4.0 5.0 6.0 7.0]' );
 
computed = optimsimplex_getallfv (s1);
 
assert_equal ( computed , [3.0 4.0 5.0 6.0 7.0]' );
 
s1 = optimsimplex_destroy(s1);
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
// Forward
 
s1 = optimsimplex_new ();
 
simplex = [
1. -2.0 1.0
4. -1.0 3.0
7. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
computed = optimsimplex_gradientfv ( s1 );
 
assert_close ( computed , [-3.0 3.0]' , 10 * %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
// Centered
 
s1 = optimsimplex_new ();
 
simplex = [
1. -2.0 1.0
4. -1.0 3.0
7. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
computed = optimsimplex_gradientfv ( s1 , method = "centered" , fun = rosenbrock );
 
assert_close ( computed , [-1636.3333333333333 -1684.8333333333333]' , 10 * %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
// Centered with additionnal arguments
 
myobj = tlist(["T_MYSTUFF","nb"]);
 
myobj.nb = 0;
 
function [ y , myobj ] = mycostf ( x , myobj )
  y = rosenbrock(x);
  myobj.nb = myobj.nb + 1
endfunction
 
s1 = optimsimplex_new ();
 
simplex = [
1. -2.0 1.0
4. -1.0 3.0
7. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
[ computed , myobj ] = optimsimplex_gradientfv ( s1 , method = "centered" , fun = mycostf , data = myobj );
 
assert_close ( computed , [-1636.3333333333333 -1684.8333333333333]' , 10 * %eps );
 
assert_equal ( myobj.nb , 2 );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
//
 
// Test optimsimplex_new with a matrix of coordinates
 
//
 
coords = [
0.0 1.0 0.0
0.0 0.0 1.0
];
 
s1 = optimsimplex_new ( coords );
 
computed = optimsimplex_getallx ( s1 );
 
expected = [
0.0 1.0 0.0
0.0 0.0 1.0
];
 
assert_equal ( computed , expected );
 
computed = optimsimplex_getn(s1);
 
assert_equal ( computed , 2 );
 
computed = optimsimplex_getnbve (s1);
 
assert_equal ( computed , 3 );
 
s1 = optimsimplex_destroy(s1);
 
 
//
 
// Test optimsimplex_new with a matrix of coordinates and 
 
// a function
 
//
 
coords = [
0.0 1.0 0.0
0.0 0.0 1.0
];
 
s1 = optimsimplex_new ( coords , rosenbrock );
 
computed = optimsimplex_getall ( s1 );
 
expected = [
    1.      0.    0.  
    100.    1.    0.  
    101.    0.    1.  
];
 
assert_equal ( computed , expected );
 
computed = optimsimplex_getn(s1);
 
assert_equal ( computed , 2 );
 
computed = optimsimplex_getnbve (s1);
 
assert_equal ( computed , 3 );
 
s1 = optimsimplex_destroy(s1);
 
 
//
 
// Test with a function which has an additional argument
 
//
 
myobj = tlist(["T_MYSTUFF","nb"]);
 
myobj.nb = 0;
 
function [ y , myobj ] = mycostf ( x , myobj )
  y = rosenbrock(x);
  myobj.nb = myobj.nb + 1
endfunction
 
coords = [
0.0 1.0 0.0
0.0 0.0 1.0
];
 
[ s1 , myobj ] = optimsimplex_new ( coords , mycostf , myobj );
 
computed = optimsimplex_getall ( s1 );
 
expected = [
    1.      0.    0.  
    100.    1.    0.  
    101.    0.    1.  
];
 
assert_equal ( computed , expected );
 
assert_equal ( myobj.nb , 3 );
 
computed = optimsimplex_getn(s1);
 
assert_equal ( computed , 2 );
 
computed = optimsimplex_getnbve (s1);
 
assert_equal ( computed , 3 );
 
s1 = optimsimplex_destroy ( s1 );
 
//
 
// Test optimsimplex_new with a matrix of coordinates made of k=5 vertices
 
//
 
coords = [
0.0 1.0 0.0 1.0 2.0
0.0 0.0 1.0 1.0 2.0
];
 
s1 = optimsimplex_new ( coords , rosenbrock );
 
computed = optimsimplex_getall ( s1 );
 
expected = [
    1.      0.    0.  
    100.    1.    0.  
    101.    0.    1.  
    0.    1.    1.  
    401.    2.    2.  
];
 
assert_equal ( computed , expected );
 
computed = optimsimplex_getn(s1);
 
assert_equal ( computed , 2 );
 
computed = optimsimplex_getnbve (s1);
 
assert_equal ( computed , 5 );
 
s1 = optimsimplex_destroy(s1);
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
// With basic function
 
simplex = [...
24.2 -1.2 1.0
93.6 -0.2 1.0
36.2 -1.2 2.0
];
 
s1 = optimsimplex_new();
 
s1 = optimsimplex_setall ( s1 , simplex );
 
s2 = optimsimplex_oriented ( s1 , rosenbrock );
 
computed = optimsimplex_getall ( s2 );
 
expected = [...
24.2 -1.2 1.0
364.5 -1.7 1.0
93.2 -1.2 0.5
];
 
assert_close ( computed , expected , %eps );
 
s1 = optimsimplex_destroy(s1);
 
s2 = optimsimplex_destroy(s2);
 
//
 
// Test with an additional argument
 
//
 
myobj = tlist(["T_MYSTUFF","nb"]);
 
myobj.nb = 0;
 
function [ y , myobj ] = mycostf ( x , myobj )
  y = rosenbrock(x);
  myobj.nb = myobj.nb + 1
endfunction
 
simplex = [...
24.2 -1.2 1.0
93.6 -0.2 1.0
36.2 -1.2 2.0
];
 
s1 = optimsimplex_new();
 
s1 = optimsimplex_setall ( s1 , simplex );
 
[s2,myobj] = optimsimplex_oriented ( s1 , mycostf , myobj );
 
computed = optimsimplex_getall ( s2 );
 
expected = [...
24.2 -1.2 1.0
364.5 -1.7 1.0
93.2 -1.2 0.5
];
 
assert_close ( computed , expected , %eps );
 
assert_equal ( myobj.nb , 2 );
 
s1 = optimsimplex_destroy(s1);
 
s2 = optimsimplex_destroy(s2);
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
 
myobj = tlist(["T_MYSTUFF","nb"]);
 
myobj.nb = 0;
 
function [ y , myobj ] = mycostf ( x , myobj )
  y = rosenbrock(x);
  myobj.nb = myobj.nb + 1
endfunction
 
s1 = optimsimplex_new ();
 
[ s1 , myobj ] = optimsimplex_pfeffer ( s1 , x0 = [-1.2 1.0] , fun = mycostf , data=myobj );
 
computed = optimsimplex_getall ( s1 );
 
expected = [
    24.2       -1.2     1.    
    39.634976  -1.26    1.    
    20.05      -1.2     1.05  
];
 
assert_close ( computed , expected , 10 * %eps );
 
assert_equal ( myobj.nb , 3 );
 
s1 = optimsimplex_destroy ( s1 );
 
 
//
 
// Pfeffer, case 0.0
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_pfeffer ( s1 , x0 = [-1.2 0.0] , fun = rosenbrock );
 
computed = optimsimplex_getall ( s1 );
 
expected = [
    212.2      -1.2     0.      
    257.15498  -1.26    0.      
    210.04562  -1.2     0.0075  
];
 
assert_close ( computed , expected , 1.e-6 );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
//
 
// Test print with all data here.
 
//
 
simplex = [...
0.0 1.0 0.0
0.0 0.0 2.0
];
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn ( s1 , 2 );
 
s1 = optimsimplex_setnbve ( s1 , 3 );
 
s1 = optimsimplex_setallx ( s1 , simplex );
 
s1 = optimsimplex_setallfv ( s1 , [12.0 13.0 14.0]' );
 
optimsimplex_print ( s1 );
Vertex #1/3 : fv=12.000000, x=0.000000 0.000000

Vertex #2/3 : fv=13.000000, x=1.000000 0.000000

Vertex #3/3 : fv=14.000000, x=0.000000 2.000000

 
s1 = optimsimplex_destroy ( s1 );
 
 
//
 
// Test print with no data
 
//
 
s1 = optimsimplex_new ();
 
optimsimplex_print ( s1 );
Empty simplex (zero dimension)

 
s1 = optimsimplex_destroy ( s1 );
 
//
 
// Test print with n set, but no data
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn ( s1 , 2 );
 
optimsimplex_print ( s1 );
Empty simplex (zero vertices)

 
s1 = optimsimplex_destroy ( s1 );
 
//
 
// Test print with n set, x set, but no function values
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn ( s1 , 2 );
 
s1 = optimsimplex_setnbve ( s1 , 3 );
 
s1 = optimsimplex_setallx ( s1 , simplex );
 
optimsimplex_print ( s1 );
Empty simplex (zero function values)

 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
//
 
// Test optimsimplex_randbounds
 
//
 
function [ y , myobj ] = mycostf ( x , myobj )
  y = rosenbrock(x);
  myobj.nb = myobj.nb + 1
endfunction
 
 
//
 
// Test randbounds
 
//
 
mydude = tlist(["T_MYSTUFF","nb"]);
 
mydude.nb = 0;
 
s1 = optimsimplex_new ();
 
[ s1 , mydude ] = optimsimplex_randbounds ( s1 , x0 = [-1.2 1.0], fun = mycostf, ...
  boundsmin = [-5.0 -5.0] , boundsmax = [5.0 5.0], nbve=5 , data = mydude );
 
computed = optimsimplex_getall ( s1 );
 
assert_equal ( size(computed,1) , 5 );
 
assert_equal ( size(computed,2) , 3 );
 
assert_equal ( mydude.nb , 5 );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
//
 
// Test optimsimplex_reflect
 
//
 
 
//
 
// Test with 3 vertices
 
//
 
s1 = optimsimplex_new ();
 
simplex = [
24.2 -1.2 1.0
93.6 -0.2 1.0
36.2 -1.2 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
r = optimsimplex_reflect ( s1 , rosenbrock );
 
computed = optimsimplex_getall ( r );
 
expected = [
24.2 -1.2 1.0
1484.8 -2.2 1.0
212.2 -1.2 0.0
];
 
assert_close ( computed , expected , 10 * %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
r = optimsimplex_destroy ( r );
 
//
 
// Test with an additional argument
 
//
 
myobj = tlist(["T_MYSTUFF","nb"]);
 
myobj.nb = 0;
 
function [ y , myobj ] = mycostf ( x , myobj )
  y = rosenbrock(x);
  myobj.nb = myobj.nb + 1
endfunction
 
s1 = optimsimplex_new ();
 
simplex = [
24.2 -1.2 1.0
93.6 -0.2 1.0
36.2 -1.2 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
[ r , myobj ] = optimsimplex_reflect ( s1 , mycostf , myobj );
 
computed = optimsimplex_getall ( r );
 
expected = [
24.2 -1.2 1.0
1484.8 -2.2 1.0
212.2 -1.2 0.0
];
 
assert_close ( computed , expected , 10 * %eps );
 
assert_equal ( myobj.nb , 2 );
 
s1 = optimsimplex_destroy ( s1 );
 
r = optimsimplex_destroy ( r );
 
//
 
// Test with 5 vertices
 
//
 
s1 = optimsimplex_new ();
 
simplex = [
24.2 -1.2 1.0
93.6 -0.2 1.0
36.2 -1.2 2.0
12.0 -2.0 -2.0
24.0 -4.0 4.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
r = optimsimplex_reflect ( s1 , rosenbrock );
 
computed = optimsimplex_getall ( r );
 
expected = [
    24.2     -1.2   1.  
    1484.8   -2.2   1.  
    212.2    -1.2   0.  
    1476.52  -0.4   4.  
    2079.72   1.6  -2.  
];
 
assert_close ( computed , expected , 10 * %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
r = optimsimplex_destroy ( r );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
//
 
// Test optimsimplex_shrink
 
//
 
//
 
// Test with 3 vertices
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn(s1,2);
 
s1 = optimsimplex_setnbve(s1,3);
 
newsimplex = [
0.0 1.0 0.0
0.0 0.0 1.0
];
 
s1 = optimsimplex_setallx ( s1 , newsimplex );
 
s1 = optimsimplex_setallfv ( s1 , [-12.0 0.0 0.0]' );
 
s1 = optimsimplex_shrink ( s1 , rosenbrock );
 
computed = optimsimplex_getall ( s1 );
 
// The function value at vertex #1 is not re-computed, as expected.
 
expected = [
  -12.    0.     0.   
    6.5    0.5    0.   
    26.    0.     0.5  
];
 
assert_equal ( computed , expected );
 
s1 = optimsimplex_destroy ( s1 );
 
//
 
// Test with an additional argument
 
//
 
myobj = tlist(["T_MYSTUFF","nb"]);
 
myobj.nb = 0;
 
function [ y , myobj ] = mycostf ( x , myobj )
  y = rosenbrock(x);
  myobj.nb = myobj.nb + 1
endfunction
 
s1 = optimsimplex_new ();
 
newsimplex = [
-12.0 0.0 0.0
6.0 1.0 0.0
7.0 0.0 1.0
];
 
s1 = optimsimplex_setall ( s1 , newsimplex );
 
[ s1 , myobj ] = optimsimplex_shrink ( s1 , mycostf , data=myobj );
 
computed = optimsimplex_getall ( s1 );
 
// The function value at vertex #1 is not re-computed, as expected.
 
expected = [
   -12.    0.     0.   
    6.5    0.5    0.   
    26.    0.     0.5  
];
 
assert_equal ( computed , expected );
 
assert_equal ( myobj.nb , 2 );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
//
 
// Test with 5 vertices
 
//
 
s1 = optimsimplex_new ();
 
newsimplex = [
12.0 0.0 0.0
12.0 1.0 0.0
12.0 0.0 1.0
12.0 1.0 1.0
12.0 2.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , newsimplex );
 
s1 = optimsimplex_shrink ( s1 , rosenbrock );
 
computed = optimsimplex_getall ( s1 );
 
// The function value at vertex #1 is not re-computed, as expected.
 
expected = [
    12.    0.     0.   
    6.5    0.5    0.   
    26.    0.     0.5  
    6.5    0.5    0.5  
    0.     1.     1.   
];
 
assert_equal ( computed , expected );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
 
//
 
// Check behaviour with default settings.
 
//
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
//
 
// Test optimsimplex_size with 3 vertices
 
//
 
simplex = [...
0.0 1.0 0.0
0.0 0.0 2.0
];
 
s1 = optimsimplex_new();
 
s1 = optimsimplex_setn ( s1 , 2 );
 
s1 = optimsimplex_setnbve ( s1 , 3 );
 
s1 = optimsimplex_setallx ( s1 , simplex );
 
ssize = optimsimplex_size ( s1 , "Nash" );
 
assert_close ( ssize , 3.0, %eps );
 
ssize = optimsimplex_size ( s1 , "diameter" );
 
assert_close ( ssize , sqrt(5), %eps );
 
ssize = optimsimplex_size ( s1 , "sigmaplus" );
 
assert_close ( ssize , 2.0, %eps );
 
ssize = optimsimplex_size ( s1 , "sigmaminus" );
 
assert_close ( ssize , 1.0, %eps );
 
s1 = optimsimplex_destroy(s1);
 
//
 
// Test optimsimplex_size with 5 vertices
 
//
 
simplex = [...
0.0 0.0 0.0
0.0 1.0 0.0
0.0 0.0 2.0
0.0 1.0 2.0
0.0 2.0 2.0
];
 
s1 = optimsimplex_new();
 
s1 = optimsimplex_setall ( s1 , simplex );
 
ssize = optimsimplex_size ( s1 , "Nash" );
 
assert_close ( ssize , 8.0644951022459796519115 , %eps );
 
ssize = optimsimplex_size ( s1 , "diameter" );
 
assert_close ( ssize , 2.8284271247461902909492 , %eps );
 
ssize = optimsimplex_size ( s1 , "sigmaplus" );
 
assert_close ( ssize , 2.8284271247461902909492 , %eps );
 
ssize = optimsimplex_size ( s1 , "sigmaminus" );
 
assert_close ( ssize , 1.0 , %eps );
 
s1 = optimsimplex_destroy(s1);
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
//
 
// Test optimsimplex_sort
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_setn(s1,2);
 
s1 = optimsimplex_setnbve(s1,3);
 
newsimplex = [
1.0 3.0 5.0
2.0 4.0 6.0
];
 
s1 = optimsimplex_setallx ( s1 , newsimplex );
 
s1 = optimsimplex_setallfv ( s1 , [5.0 2.0 1.0]' );
 
s1 = optimsimplex_sort ( s1 );
 
ve1 = optimsimplex_getve ( s1 , 1 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [5.0 6.0]' );
 
assert_equal ( ve1.fv , 1.0 );
 
ve1 = optimsimplex_getve ( s1 , 2 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [3.0 4.0]' );
 
assert_equal ( ve1.fv , 2.0 );
 
ve1 = optimsimplex_getve ( s1 , 3 );
 
assert_equal ( ve1.n , 2 );
 
assert_equal ( ve1.x , [1.0 2.0]' );
 
assert_equal ( ve1.fv , 5.0 );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
 
 
 
myobj = tlist(["T_MYSTUFF","nb"]);
 
myobj.nb = 0;
 
function [ y , myobj ] = mycostf ( x , myobj )
  y = rosenbrock(x);
  myobj.nb = myobj.nb + 1
endfunction
 
s1 = optimsimplex_new ();
 
[ s1 , myobj ] = optimsimplex_spendley ( s1 , x0 = [-1.2 1.0] , fun = mycostf , data=myobj );
 
computed = optimsimplex_getall ( s1 );
 
expected = [
    24.2   -1.2    1.                        
    146.4913601204771680386   -0.2340741737109317543997    1.2588190451025207394764  
    120.43069965448485447723  -0.9411809548974792161147    1.9659258262890682011914  
];
 
assert_close ( computed , expected , 10 * %eps );
 
assert_equal ( myobj.nb , 3 );
 
s1 = optimsimplex_destroy ( s1 );
 
 
//
 
// Pfeffer, case 0.0
 
//
 
s1 = optimsimplex_new ();
 
s1 = optimsimplex_spendley ( s1 , x0 = [-1.2 1.0] , fun = rosenbrock );
 
computed = optimsimplex_getall ( s1 );
 
expected = [
    24.2   -1.2    1.                        
    146.4913601204771680386   -0.2340741737109317543997    1.2588190451025207394764  
    120.43069965448485447723  -0.9411809548974792161147    1.9659258262890682011914  
];
 
assert_close ( computed , expected , 1.e-6 );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
 
s1 = optimsimplex_new ();
 
simplex = [
24. -2.0 1.0
93. -1.0 3.0
36. -3.0 2.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
str = optimsimplex_tostring ( s1 );
 
assert_equal ( str(1) , "Vertex #1/3 : fv=24.000000, x=-2.000000 1.000000" );
 
assert_equal ( str(2) , "Vertex #2/3 : fv=93.000000, x=-1.000000 3.000000" );
 
assert_equal ( str(3) , "Vertex #3/3 : fv=36.000000, x=-3.000000 2.000000" );
 
s1 = optimsimplex_destroy ( s1 );
 
 
 
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
 
//
 
// This file must be used under the terms of the CeCILL.
 
// This source file is licensed as described in the file COPYING, which
 
// you should have received as part of this distribution.  The terms
 
// are also available at
 
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 
 
//
 
// assert_close --
 
//   Returns 1 if the two real matrices computed and expected are close,
 
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
//
 
// assert_equal --
 
//   Returns 1 if the two real matrices computed and expected are equal.
 
// Arguments
 
//   computed, expected : the two matrices to compare
 
//   epsilon : a small number
 
//
 
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then pause,end
endfunction
 
// iexcl by default
 
s1 = optimsimplex_new ();
 
simplex = [
24.2 -1.2 1.0
36.2 -1.2 2.0
93.6 -0.2 1.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
cen = optimsimplex_xbar ( s1 );
 
assert_close ( cen , [-1.2 1.5]', %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
// iexcl =2
 
s1 = optimsimplex_new ();
 
simplex = [
24.2 -1.2 1.0
36.2 -1.2 2.0
93.6 -0.2 1.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
cen = optimsimplex_xbar ( s1 , 2 );
 
assert_close ( cen , [-0.7 1.0]', %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
//
 
// Test with 5 vertices
 
//
 
s1 = optimsimplex_new ();
 
simplex = [
24.2 -1.2 1.0
36.2 -1.2 2.0
93.6 -0.2 1.0
93.6 0.0 0.0
93.6 10.0 10.0
];
 
s1 = optimsimplex_setall ( s1 , simplex );
 
cen = optimsimplex_xbar ( s1 );
 
assert_close ( cen , [-0.65 1.0]', %eps );
 
s1 = optimsimplex_destroy ( s1 );
 
 
