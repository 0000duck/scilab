// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
//
// This file must be used under the terms of the CeCILL.
// This source file is licensed as described in the file COPYING, which
// you should have received as part of this distribution.  The terms
// are also available at
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
//
// assert_close --
//   Returns 1 if the two real matrices computed and expected are close,
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
// Arguments
//   computed, expected : the two matrices to compare
//   epsilon : a small number
//
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then bugmes();quit;end
endfunction
//
// assert_equal --
//   Returns 1 if the two real matrices computed and expected are equal.
// Arguments
//   computed, expected : the two matrices to compare
//   epsilon : a small number
//
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then bugmes();quit;end
endfunction
function [ y , index ] = rosenbrock ( x , index )
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
//
// Test basic use without parameters
//
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] );
assert_close ( x , [1.0   1.0], 1e-4 );
assert_close ( fval , 0.0 , 1e-4 );
assert_equal ( exitflag , 1 );
assert_equal ( output.iterations , 85 );
assert_equal ( output.algorithm , "Nelder-Mead simplex direct search" );
assert_equal ( output.funcCount , 159 );
assert_equal ( output.message(1) , "Optimization terminated:");
assert_equal ( output.message(2) , " the current x satisfies the termination criteria using OPTIONS.TolX of 1.000000e-004");
assert_equal ( output.message(3) , " and F(X) satisfies the convergence criteria using OPTIONS.TolFun of 1.000000e-004");
// 
// fminsearch with incorrect number of input arguments
//
cmd = "fminsearch ( )";
execstr(cmd,"errcatch");
computed = lasterror();
expected = "fminsearch: Unexpected number of input arguments : 0 provided while 2 or 3 are expected.";
assert_equal ( computed , expected );
//
// Check that tolerance on X is correctly taken into account
//
opt = optimset ( "TolX" , 1.e-2 );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
assert_close ( x , [1.0 1.0], 1.e-2 );
assert_close ( fval , 0.0 , 1e-4 );
assert_equal ( exitflag , 1 );
assert_equal ( output.iterations , 70 );
assert_equal ( output.funcCount , 130 );
//
// Check that tolerance on F is correctly taken into account
//
opt = optimset ( "TolFun" , 1.e-10 );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
assert_close ( x , [1.0 1.0], 1.e-4 );
assert_close ( fval , 0.0 , 1e-2 );
assert_equal ( exitflag , 1 );
assert_equal ( output.iterations , 90 );
assert_equal ( output.funcCount , 168 );
//
// Check that maximum number of iterations is correctly taken into account
//
opt = optimset ( "MaxIter" , 10 );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
Exiting: Maximum number of iterations has been exceeded

         - increase MaxIter option.

         Current function value: 4.1355598

assert_close ( x , [1.0 1.0], 1.e1 );
assert_close ( fval , 0.0 , 1e1 );
assert_equal ( exitflag , 0 );
assert_equal ( output.iterations , 10 );
assert_equal ( output.funcCount , 21 );
//
// Check that maximum number of function evaluations is correctly taken into account
//
opt = optimset ( "MaxFunEvals" , 10 );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
Exiting: Maximum number of function evaluations has been exceeded

         - increase MaxFunEvals option.

         Current function value: 4.3813601

assert_close ( x , [1.0 1.0], 1.e1 );
assert_close ( fval , 0.0 , 1e1 );
assert_equal ( exitflag , 0 );
assert_equal ( output.iterations , 5 );
assert_equal ( output.funcCount , 11 );
//
// Check that Display is correctly used in mode "final"
//
opt = optimset ( "Display" , "final" );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
Optimization terminated:

 the current x satisfies the termination criteria using OPTIONS.TolX of 1.000000e-004

 and F(X) satisfies the convergence criteria using OPTIONS.TolFun of 1.000000e-004

assert_close ( x , [1.0 1.0], 1.e-4 );
assert_close ( fval , 0.0 , 1.e-4 );
assert_equal ( exitflag , 1 );
assert_equal ( output.iterations , 85 );
assert_equal ( output.funcCount , 159 );
//
// Check that Display is correctly used in mode "iter"
//
opt = optimset ( "Display" , "iter" );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
 Iteration   Func-count     min f(x)         Procedure

     0            3             24.2                             

     1            3            20.05         initial simplex     

     2            5         5.161796         expand              

     3            7         4.497796         reflect             

     4            9         4.497796         contract outside    

     5           11        4.3813601         contract inside     

     6           13        4.2452728         contract inside     

     7           15        4.2176247         reflect             

     8           17        4.2112906         contract inside     

     9           19        4.1355598         expand              

    10           21        4.1355598         contract inside     

    11           23        4.0127268         expand              

    12           25        3.9373812         expand              

    13           27         3.602606         expand              

    14           28         3.602606         reflect             

    15           30        3.4662211         reflect             

    16           32        3.2160547         expand              

    17           34        3.1649126         reflect             

    18           36        2.7068692         expand              

    19           37        2.7068692         reflect             

    20           39        2.0021824         expand              

    21           41        2.0021824         contract inside     

    22           43        2.0021824         contract inside     

    23           45        1.8154337         expand              

    24           47        1.7348144         contract outside    

    25           49        1.3169723         expand              

    26           50        1.3169723         reflect             

    27           51        1.3169723         reflect             

    28           53        1.1595038         reflect             

    29           55        1.0767387         contract inside     

    30           57        0.8834921         reflect             

    31           59        0.8834921         contract inside     

    32           61        0.6691654         expand              

    33           63        0.6691654         contract inside     

    34           64        0.6691654         reflect             

    35           66        0.5367289         reflect             

    36           68        0.5367289         contract inside     

    37           70        0.4232940         expand              

    38           72        0.4232940         contract outside    

    39           74        0.3985272         reflect             

    40           76        0.3144704         expand              

    41           77        0.3144704         reflect             

    42           79        0.1903167         expand              

    43           81        0.1903167         contract inside     

    44           82        0.1903167         reflect             

    45           84        0.1369602         reflect             

    46           86        0.1369602         contract outside    

    47           88        0.1131281         contract outside    

    48           90        0.1105304         contract inside     

    49           92        0.1023402         reflect             

    50           94        0.1011837         contract inside     

    51           96        0.0794969         expand              

    52           97        0.0794969         reflect             

    53           98        0.0794969         reflect             

    54          100        0.0569294         expand              

    55          102        0.0569294         contract inside     

    56          104        0.0344855         expand              

    57          106        0.0179534         expand              

    58          108        0.0169469         contract outside    

    59          110        0.0040146         reflect             

    60          112        0.0040146         contract inside     

    61          113        0.0040146         reflect             

    62          115        0.0003700         reflect             

    63          117        0.0003700         contract inside     

    64          118        0.0003700         reflect             

    65          120        0.0003700         contract inside     

    66          122        0.0000590         contract outside    

    67          124        0.0000337         contract inside     

    68          126        0.0000337         contract outside    

    69          128        0.0000189         contract outside    

    70          130        0.0000085         contract inside     

    71          132        0.0000029         contract inside     

    72          133        0.0000029         reflect             

    73          135        0.0000007         contract inside     

    74          137        0.0000007         contract inside     

    75          139        0.0000006         contract inside     

    76          141        0.0000002         contract outside    

    77          143        0.0000001         contract inside     

    78          145        5.235D-08         contract inside     

    79          147        5.035D-08         contract inside     

    80          149        2.004D-08         contract inside     

    81          151        1.123D-09         contract inside     

    82          153        1.123D-09         contract outside    

    83          155        1.123D-09         contract inside     

    84          157        1.108D-09         contract outside    

    85          159        8.178D-10         contract inside     



Optimization terminated:

 the current x satisfies the termination criteria using OPTIONS.TolX of 1.000000e-004

 and F(X) satisfies the convergence criteria using OPTIONS.TolFun of 1.000000e-004

assert_close ( x , [1.0 1.0], 1.e-4 );
assert_close ( fval , 0.0 , 1.e-4 );
assert_equal ( exitflag , 1 );
assert_equal ( output.iterations , 85 );
assert_equal ( output.funcCount , 159 );
//
// Check that Display is correctly used in mode "off" (no message at all)
//
opt = optimset ( "Display" , "off" );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
assert_close ( x , [1.0 1.0], 1.e-4 );
assert_close ( fval , 0.0 , 1.e-4 );
assert_equal ( exitflag , 1 );
assert_equal ( output.iterations , 85 );
assert_equal ( output.funcCount , 159 );
//
// Check that Display is correctly used in mode "notify" (display only problem messages)
//
opt = optimset ( "Display" , "notify" );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
assert_close ( x , [1.0 1.0], 1.e-4 );
assert_close ( fval , 0.0 , 1.e-4 );
assert_equal ( exitflag , 1 );
assert_equal ( output.iterations , 85 );
assert_equal ( output.funcCount , 159 );
//
// Check that Display is correctly used in mode "off" (no message at all), when there is a maximum number of iterations reached
//
opt = optimset ( "Display" , "off" , "MaxIter" , 10 );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
assert_close ( x , [1.0 1.0], 1.e1 );
assert_close ( fval , 0.0 , 1e1 );
assert_equal ( exitflag , 0 );
assert_equal ( output.iterations , 10 );
assert_equal ( output.funcCount , 21 );
//
// Check that Display is correctly used in mode "notify" (display only problem messages), when there is a maximum number of iterations reached
//
opt = optimset ( "Display" , "notify" , "MaxIter" , 10 );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
Exiting: Maximum number of iterations has been exceeded

         - increase MaxIter option.

         Current function value: 4.1355598

assert_close ( x , [1.0 1.0], 1.e1 );
assert_close ( fval , 0.0 , 1e1 );
assert_equal ( exitflag , 0 );
assert_equal ( output.iterations , 10 );
assert_equal ( output.funcCount , 21 );
//
// Check that Display is correctly used in mode "iter", when there is a maximum number of iterations reached
//
opt = optimset ( "Display" , "iter" , "MaxIter" , 10 );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
 Iteration   Func-count     min f(x)         Procedure

     0            3             24.2                             

     1            3            20.05         initial simplex     

     2            5         5.161796         expand              

     3            7         4.497796         reflect             

     4            9         4.497796         contract outside    

     5           11        4.3813601         contract inside     

     6           13        4.2452728         contract inside     

     7           15        4.2176247         reflect             

     8           17        4.2112906         contract inside     

     9           19        4.1355598         expand              

    10           21        4.1355598         contract inside     



Exiting: Maximum number of iterations has been exceeded

         - increase MaxIter option.

         Current function value: 4.1355598

assert_close ( x , [1.0 1.0], 1.e1 );
assert_close ( fval , 0.0 , 1e1 );
assert_equal ( exitflag , 0 );
assert_equal ( output.iterations , 10 );
assert_equal ( output.funcCount , 21 );
//
// Check that Display is correctly used in mode "final", when there is a maximum number of iterations reached
//
opt = optimset ( "Display" , "final" , "MaxIter" , 10 );
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1] , opt );
Exiting: Maximum number of iterations has been exceeded

         - increase MaxIter option.

         Current function value: 4.1355598

assert_close ( x , [1.0 1.0], 1.e1 );
assert_close ( fval , 0.0 , 1e1 );
assert_equal ( exitflag , 0 );
assert_equal ( output.iterations , 10 );
assert_equal ( output.funcCount , 21 );
//
// Use output function
//
// outfun --
//   A sample output function
// Arguments, input
//   x : the current point
//   optimValues : a tlist which contains the following fields
//     funccount : the number of function evaluations
//     fval : the current function value
//     iteration : the current iteration
//     procedure : a string containing the current type of step
//  state : the current state of the algorithm
//    "init", "iter", "done"
//
function outfun ( x , optimValues , state )
  plot( x(1),x(2),'.');
  // Unload all fields and check consistent values
  fc = optimValues.funccount;
  fv = optimValues.fval;
  it = optimValues.iteration;
  pr = optimValues.procedure;
  select pr
  case "initial simplex"
    // OK
  case "expand"
    // OK
  case "reflect"
    // OK
  case "shrink"
    // OK
  case "contract inside"
    // OK
  case "contract outside"
    // OK
  case ""
    // OK
  else
    error ( sprintf ( "Unknown procedure %s." , pr ) )
  end
  select state
  case "init"
    // OK
  case "iter"
    // OK
  case "done"
    // OK
  else
    error ( sprintf ( "Unknown state %s." , state ) )
  end
  mprintf ( "%d %e %d -%s- %s\n" , fc , fv , it , pr , state )
endfunction
opt = optimset ( "OutputFcn" , outfun);
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
3 2.420000e+001 0 -- init

3 2.005000e+001 1 -initial simplex- iter

5 5.161796e+000 2 -expand- iter

7 4.497796e+000 3 -reflect- iter

9 4.497796e+000 4 -contract outside- iter

11 4.381360e+000 5 -contract inside- iter

13 4.245273e+000 6 -contract inside- iter

15 4.217625e+000 7 -reflect- iter

17 4.211291e+000 8 -contract inside- iter

19 4.135560e+000 9 -expand- iter

21 4.135560e+000 10 -contract inside- iter

23 4.012727e+000 11 -expand- iter

25 3.937381e+000 12 -expand- iter

27 3.602606e+000 13 -expand- iter

28 3.602606e+000 14 -reflect- iter

30 3.466221e+000 15 -reflect- iter

32 3.216055e+000 16 -expand- iter

34 3.164913e+000 17 -reflect- iter

36 2.706869e+000 18 -expand- iter

37 2.706869e+000 19 -reflect- iter

39 2.002182e+000 20 -expand- iter

41 2.002182e+000 21 -contract inside- iter

43 2.002182e+000 22 -contract inside- iter

45 1.815434e+000 23 -expand- iter

47 1.734814e+000 24 -contract outside- iter

49 1.316972e+000 25 -expand- iter

50 1.316972e+000 26 -reflect- iter

51 1.316972e+000 27 -reflect- iter

53 1.159504e+000 28 -reflect- iter

55 1.076739e+000 29 -contract inside- iter

57 8.834921e-001 30 -reflect- iter

59 8.834921e-001 31 -contract inside- iter

61 6.691654e-001 32 -expand- iter

63 6.691654e-001 33 -contract inside- iter

64 6.691654e-001 34 -reflect- iter

66 5.367289e-001 35 -reflect- iter

68 5.367289e-001 36 -contract inside- iter

70 4.232940e-001 37 -expand- iter

72 4.232940e-001 38 -contract outside- iter

74 3.985272e-001 39 -reflect- iter

76 3.144704e-001 40 -expand- iter

77 3.144704e-001 41 -reflect- iter

79 1.903167e-001 42 -expand- iter

81 1.903167e-001 43 -contract inside- iter

82 1.903167e-001 44 -reflect- iter

84 1.369602e-001 45 -reflect- iter

86 1.369602e-001 46 -contract outside- iter

88 1.131281e-001 47 -contract outside- iter

90 1.105304e-001 48 -contract inside- iter

92 1.023402e-001 49 -reflect- iter

94 1.011837e-001 50 -contract inside- iter

96 7.949687e-002 51 -expand- iter

97 7.949687e-002 52 -reflect- iter

98 7.949687e-002 53 -reflect- iter

100 5.692937e-002 54 -expand- iter

102 5.692937e-002 55 -contract inside- iter

104 3.448549e-002 56 -expand- iter

106 1.795342e-002 57 -expand- iter

108 1.694692e-002 58 -contract outside- iter

110 4.014627e-003 59 -reflect- iter

112 4.014627e-003 60 -contract inside- iter

113 4.014627e-003 61 -reflect- iter

115 3.699544e-004 62 -reflect- iter

117 3.699544e-004 63 -contract inside- iter

118 3.699544e-004 64 -reflect- iter

120 3.699544e-004 65 -contract inside- iter

122 5.901115e-005 66 -contract outside- iter

124 3.366824e-005 67 -contract inside- iter

126 3.366824e-005 68 -contract outside- iter

128 1.891590e-005 69 -contract outside- iter

130 8.460826e-006 70 -contract inside- iter

132 2.882547e-006 71 -contract inside- iter

133 2.882547e-006 72 -reflect- iter

135 7.489972e-007 73 -contract inside- iter

137 7.489972e-007 74 -contract inside- iter

139 6.203654e-007 75 -contract inside- iter

141 2.169195e-007 76 -contract outside- iter

143 1.002443e-007 77 -contract inside- iter

145 5.234866e-008 78 -contract inside- iter

147 5.035031e-008 79 -contract inside- iter

149 2.004302e-008 80 -contract inside- iter

151 1.122930e-009 81 -contract inside- iter

153 1.122930e-009 82 -contract outside- iter

155 1.122930e-009 83 -contract inside- iter

157 1.107549e-009 84 -contract outside- iter

159 8.177661e-010 85 -contract inside- iter

159 8.177661e-010 85 -- done

close();
//
// Use several output functions
//
function outfun2 ( x , optimValues , state )
  scf ( fig1 );
  plot( x(1),x(2),'.');
endfunction
function outfun3 ( x , optimValues , state )
  scf ( fig2 );
  plot( x(1),x(2),'o');
endfunction
myfunctions = list ( outfun2 , outfun3 );
fig1 = scf(1000);
fig2 = scf(1001);
opt = optimset ( "OutputFcn" , myfunctions );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close(fig1);
close(fig2);
//
// Use plot function
//
//
// plotfun --
//   A sample plot function
// Arguments, input
//   x : the current point
//   optimValues : a tlist which contains the following fields
//     funcCount" : the number of function evaluations
//     fval : the current function value
//     iteration : the current iteration
//     procedure : a string containing the current type of step
//  state : the current state of the algorithm
//    "init", "iter", "done"
//
function plotfun ( x , optimValues , state )
  plot(x(1),x(2),'.');
endfunction
opt = optimset ( "PlotFcns" , plotfun);
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close();
//
// Use several plot functions
//
function plotfun2 ( x , optimValues , state )
  scf ( fig1 );
  plot( x(1),x(2),'.');
endfunction
function plotfun3 ( x , optimValues , state )
  scf ( fig2 );
  plot( x(1),x(2),'o');
endfunction
myfunctions = list ( plotfun2 , plotfun3 );
fig1 = scf(1000);
fig2 = scf(1001);
opt = optimset ( "PlotFcns" , myfunctions );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close(fig1);
close(fig2);
//
// Use optimplotfval plot function
//
opt = optimset ( "PlotFcns" , optimplotfval );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close();
//
// Use optimplotx plot function
//
opt = optimset ( "PlotFcns" , optimplotx );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close();
//
// Use optimplotfunccount plot function
//
opt = optimset ( "PlotFcns" , optimplotfunccount );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close();
//
// Use all 3 plot functions
//
myfunctions = list ( optimplotfval , optimplotx , optimplotfunccount );
opt = optimset ( "PlotFcns" , myfunctions );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close();
//
// Test basic use with column x0
//
[x , fval , exitflag , output] = fminsearch ( rosenbrock , [-1.2 1].' );
assert_close ( x , [1.0   1.0], 1e-4 );
