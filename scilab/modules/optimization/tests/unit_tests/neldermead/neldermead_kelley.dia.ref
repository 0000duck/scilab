// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
//
// This file must be used under the terms of the CeCILL.
// This source file is licensed as described in the file COPYING, which
// you should have received as part of this distribution.  The terms
// are also available at
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
tbxhome=getenv("SCILABTBX");
loader = tbxhome + filesep() + 'neldermead'+ filesep() + 'loader.sce';
 
 Start Nelder-Mead Toolbox   
 
 Load macros from :   
 
 D:\Baudin\PROJET~1\TOOLBO~1\NELDER~1\macros\   
 
 Load help   
//
// assert_close --
//   Returns 1 if the two real matrices computed and expected are close,
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
// Arguments
//   computed, expected : the two matrices to compare
//   epsilon : a small number
//
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then bugmes();quit;end
endfunction
function y = rosenbrock (x)
//global index
//index = index + 1
y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
//mprintf("call #%d, x=(%f,%f), y=%f\n",index,x(1),x(2),y);
endfunction
//global index
//index = 0
x0 = [];
P0 = [1.1 1.1]';
x0(:,1) = P0;
x0(:,2) = P0 + 0.1 * [1 0]';
x0(:,3) = P0 + 0.1 * [0 1]';
x_opt = neldermead_kelley(x0, rosenbrock, tol=1.e-16, maxit=10000,budget=200,verbose=0,oshrink=0);
computed = x_opt(:,1);
assert_close ( computed, [1;1], 1e-8 );
// Add verbose and see if it still works
x_opt = neldermead_kelley(x0, rosenbrock, tol=1.e-16, maxit=10000,budget=20,verbose=1,oshrink=0);
x0=
tol=0.000000
maxit=10000.000000
budget=20.000000
Step #1 : order
Step #2 : reflect
xbar=1.1 1.15
xrho=1 1.2, f(xrho)=4.000000
Step #4 : contract - outside
xc=1.05 1.175, f(xc)=0.528125
	> Accept xc
Step #1 : order
Step #2 : reflect
xbar=1.075 1.1875
xrho=1.05 1.275, f(xrho)=2.978125
Step #4 : contract - inside
xcc=1.0875 1.14375, f(xcc)=0.159026
	> Accept xcc
Step #1 : order
Step #2 : reflect
xbar=1.09375 1.171875
xrho=1.1375 1.16875, f(xrho)=1.585315
Step #4 : contract - inside
xcc=1.071875 1.1734375, f(xcc)=0.065296
	> Accept xcc
Step #1 : order
Step #2 : reflect
xbar=1.0859375 1.1867188
xrho=1.084375 1.2296875, f(xrho)=0.296761
Step #4 : contract - inside
xcc=1.0867188 1.1652344, f(xcc)=0.032242
	> Accept xcc
Step #1 : order
Step #2 : reflect
xbar=1.0933594 1.1826172
xrho=1.1148438 1.1917969, f(xrho)=0.274103
Step #4 : contract - inside
xcc=1.0826172 1.1780273, f(xcc)=0.010387
	> Accept xcc
Step #1 : order
Step #2 : reflect
xbar=1.0913086 1.1890137
xrho=1.0958984 1.212793, f(xrho)=0.023120
Step #4 : contract - outside
xc=1.0936035 1.2009033, f(xc)=0.011197
	> Accept xc
Step #1 : order
Step #2 : reflect
xbar=1.0881104 1.1894653
xrho=1.0762207 1.1789307, f(xrho)=0.048574
Step #4 : contract - inside
xcc=1.0940552 1.1947327, f(xcc)=0.009341
	> Accept xcc
Step #1 : order
Step #2 : reflect
xbar=1.0883362 1.18638
xrho=1.0830688 1.1718567, f(xrho)=0.007040
Step #3 : expand
xe=1.0778015 1.1573334, f(xe)=0.007922
	> Accept xr
Step #1 : order
Step #2 : reflect
xbar=1.088562 1.1832947
xrho=1.0945068 1.188562, f(xrho)=0.017736
Step #4 : contract - inside
xcc=1.0855896 1.180661, f(xcc)=0.007791
	> Accept xcc
Step #1 : order
computed = x_opt(:,1);
assert_close ( computed, [1;1], 1e0 );
