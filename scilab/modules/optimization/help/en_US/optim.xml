<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:db="http://docbook.org/ns/docbook" version="5.0-subset Scilab" xml:lang="en" xml:id="optim">
  <info>
    <pubdate>$LastChangedDate$</pubdate>
  </info>
  <refnamediv>
    <refname>optim</refname>
    <refpurpose> non-linear optimization routine</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Calling Sequence</title>
    <synopsis>[f,xopt]=optim(costf,x0)
[f [,xopt [,gradopt [,work]]]]=optim(costf [,&lt;contr&gt;],x0 [,algo] [,df0 [,mem]] [,work] [,&lt;stop&gt;] [,&lt;params&gt;] [,imp=iflag])</synopsis>
  </refsynopsisdiv>
  <refsection>
    <title>Parameters</title>
    <variablelist>
      <varlistentry>
        <term>costf</term>
        <listitem>
          <para>external, i.e Scilab function list or string
	    (<literal>costf</literal> is the cost function: see below its calling
	    sequence (Scilab or Fortran)). See also external for details about
	    external functions.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>x0</term>
        <listitem>
          <para>real vector (initial value of variable to be minimized).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>f</term>
        <listitem>
          <para>value of optimal cost (<literal>f=costf(xopt)</literal>)</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>xopt</term>
        <listitem>
          <para>best value of <literal>x</literal> found.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>&lt;contr&gt;</term>
        <listitem>
          <para>keyword representing the following sequence of arguments:
	    <literal>'b',binf,bsup</literal>  with <literal>binf</literal> and 
	    <literal>bsup</literal> are real vectors with same dimension as
	    <literal>x0</literal>. <literal>binf</literal> and <literal>bsup</literal> are lower
	    and upper bounds on <literal>x</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>algo</term>
        <listitem>
          <para>Character string used to sprecify the algorithm to use. The
	    possible values are <literal>'qn'</literal> for quasi-Newton (default) or
	    <literal>'gc'</literal> for conjugate gradient or <literal>'nd'</literal> for
	    non-differentiable.  Note that
	    <literal>'nd'</literal> does not accept bounds on <literal>x</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>df0</term>
        <listitem>
          <para>real scalar. Guessed decreasing of <literal>f</literal> at first
	    iteration. (<literal>df0=1</literal> is the default value).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>mem :  </term>
        <listitem>
          <para>integer, number of variables used to approximate the  Hessian,
	    (<literal>algo='gc' or 'nd'</literal>). Default value is around 6.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>&lt;stop&gt;</term>
        <listitem>
          <para> keyword representing the sequence of optional parameters
	    controlling the  convergence of the algorithm. 
            <literal>'ar',nap [,iter [,epsg [,epsf [,epsx]]]]</literal></para>
          <variablelist>
            <varlistentry>
              <term>"ar"  </term>
              <listitem>
                <para>reserved keyword for stopping rule selection defined as
		  follows:</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>nap</term>
              <listitem>
                <para>maximum number of calls to <literal>costf</literal> allowed
		  (default is 100).</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>iter</term>
              <listitem>
                <para>maximum number of iterations allowed (default is 100).</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>epsg</term>
              <listitem>
                <para>threshold on gradient norm.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>epsf</term>
              <listitem>
                <para>threshold controlling decreasing of <literal>f</literal></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>epsx</term>
              <listitem>
                <para>threshold controlling variation of <literal>x</literal>. This
		  vector (possibly matrix) of same size as <literal>x0</literal> can
		  be used to scale <literal>x</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>&lt;params&gt; </term>
        <listitem>
          <para>keyword representing the sequence of arguments: 
          <literal>'ti', valti ,'td', valtd</literal> which can be used to pass argument to
	    an external written in C or Fortran (see below).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>"imp=iflag"  </term>
        <listitem>
          <para>named argument used to set the trace mode. <literal>iflag=0</literal>
	    nothing (execpt errors) is reported, <literal>iflag=1</literal> initial
	    and final reports, <literal>iflag=2</literal> adds a report per
	    iteration, <literal>iflag&gt;2</literal> add reports on linear
	    search. Warning, most of these reports are written on the Scilab
	    standard output.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>gradopt</term>
        <listitem>
          <para> gradient of <literal>costf</literal> at <literal>xopt</literal></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>work</term>
        <listitem>
          <para>working array for hot restart for quasi-Newton method. This
	    array is automatically initialized by <literal>optim</literal> when
	    <literal>optim</literal> is invoked. It can be used as input parameter to
	    speed-up the calculations.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Description</title>
    <para>
      Non-linear optimization routine for programs without constraints or with
      bound constraints:</para>
    <programlisting><![CDATA[
      
      min costf(x) w.r.t x.
      
    ]]></programlisting>
    <para><literal>costf</literal> is an "external" i.e a Scilab function, a
      list or a string giving the name of a C or Fortran routine (see
      "external").
      
      This external must return the value <literal>f</literal> of the cost function
      at the point <literal>x</literal> and the gradient <literal>g</literal> of the cost
      function at the point <literal>x</literal>. 
    </para>
    <variablelist>
      <varlistentry>
        <term>- Scilab function case</term>
        <listitem>
          <para>If <literal>costf</literal> is a Scilab function, the calling sequence
	  for <literal>costf</literal> must be:
	  <literal>[f,g,ind]=costf(x,ind)</literal></para>
          <para>Here, <literal>costf</literal> is a function which returns <literal>f</literal>,
	  value (real number) of cost function at <literal>x</literal>, and
	  <literal>g</literal>, gradient vector of cost function at
	  <literal>x</literal>. The variable <literal>ind</literal>  is described below.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>- List case</term>
        <listitem>
          <para>If <literal>costf</literal> is a list, it should be of the form:
	  <literal>list(real_costf, arg1,...,argn)</literal> with <literal>real_costf</literal>
	  a Scilab function with calling sequence :
	  <literal>[f,g,ind]=costf(x,ind,arg1,... argn)</literal>. The
	  <literal>x</literal>, <literal>f</literal>, <literal>g</literal>, <literal>ind</literal>
	  arguments have the same meaning that above. <literal>argi</literal>
	  arguments can be used to pass function parameters.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>- String case</term>
        <listitem>
          <para>If <literal>costf</literal> is a character string, it refers to the name
	  of a C or Fortran routine which must be linked to Scilab </para>
          <variablelist>
            <varlistentry>
              <term>* Fortran case</term>
              <listitem>
                <para>The generic calling sequence for the Fortran subroutine is: 
	      <literal>subroutine costf(ind,n,x,f,g,ti,tr,td)</literal> with the
	      following declarations:</para>
                <programlisting><![CDATA[
	      
	      integer ind,n ti(*)
	      double precision x(n),f,g(n),td(*)
	      real tr(*)
	      
	    ]]></programlisting>
                <para>The argument <literal>ind</literal> is described below.</para>
                <para>The Fortran subroutine <literal>costf</literal> must return <literal>f</literal>
	      and the vector <literal>g</literal>, given <literal>x, ind, n, ti, tr,td</literal>.</para>
                <para><literal>ti,tr,td</literal> can be used to initialize parameters. In
	      the calling sequence of <literal>optim</literal>, the keyword
	      <literal>&lt;params&gt;'</literal> can be replaced by <literal>'ti', valti ,'td', valtd</literal>
		.  Then, the routine  <literal>costf</literal> is
	      evaluated with <literal>ti=valti</literal> and 
	      <literal>td=valtd</literal> whatever the value of
	      <literal>ind</literal>. Thus, the Scilab variables <literal>valti</literal>
	      and <literal>valtd</literal> (integer vector and real vector) are sent
	      to the routine <literal>costf</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>* C case</term>
              <listitem>
                <para>The generic calling sequence for the C procedure is: 
	    <literal>void costf(int *ind, int *n, double *x, double *f, double *g, int *ti, float *tr, double *td)</literal>
             with the following declarations:</para>
                <para>The argument <literal>ind</literal> is described below.</para>
                <para>The C procedure <literal>costf</literal> must return <literal>f</literal>
	      and the vector <literal>g</literal>, given <literal>x, ind, n, ti, tr, td</literal>.</para>
                <para><literal>ti,tr,td</literal> can be used to initialize parameters. In
	      the calling sequence of <literal>optim</literal>, the string
	      <literal>'in'</literal> can be replaced by <literal>'ti', valti ,'td', valtd</literal>.  
	      Then, the procedure  <literal>costf</literal> is
	      evaluated with <literal>ti=valti</literal> and 
	      <literal>td=valtd</literal> whatever the value of
	      <literal>ind</literal>. Thus, the Scilab variables <literal>valti</literal>
	      and <literal>valtd</literal> (integer vector and real vector) are sent
	      to the procedure <literal>costf</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>If <literal>ind=2</literal> (resp. <literal>3, 4</literal>), <literal>costf</literal>
      must provide <literal>f</literal> (resp. <literal>g, f</literal> and
      <literal>g</literal>).</para>
    <para>If <literal>ind=1</literal> nothing is computed (used for display purposes
      only).</para>
    <para> On output, <literal>ind&lt;0</literal>  means that <literal>f</literal> cannot
      be evaluated at <literal>x</literal> and <literal>ind=0</literal> interrupts
      the optimization.</para>
  </refsection>
  <refsection>
    <title>Examples</title>
    <programlisting role="example"><![CDATA[
    
    // External function written in Scilab
    xref=[1;2;3];x0=[1;-1;1]
    deff('[f,g,ind]=cost(x,ind)','f=0.5*norm(x-xref)^2,g=x-xref');
    // Simplest call
    [f,xopt]=optim(cost,x0)
    // By conjugate gradient - you can use 'qn', 'gc' or 'nd'
    [f,xopt,gopt]=optim(cost,x0,'gc')
    //Seen as non differentiable
    [f,xopt,gopt]=optim(cost,x0,'nd')
    // Upper and lower bounds on x
    [f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0)
    // Upper and lower bounds on x and setting up the algorithm to 'gc'
    [f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0,'gc')
    // Bound on the number of call to the objective function
    [f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0,'gc','ar',3)
    // Set max number of call to the objective function (3)
    // Set max number of iterations (100)
    // Set stopping threshold on the value of f (1e-6), 
    // on the value of the norm of the gradient of the objective function (1e-6)
    // on the improvement on the parameters x_opt (1e-6;1e-6;1e-6)
    [f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0,'gc','ar',3,100,1e-6,1e-6,[1e-3;1e-3;1e-3])
    // Print information messages while optimizing
    // Be careful, some messages are printed in a terminal. You must
    // Scilab from the command line to see these messages.
    [f,xopt]=optim(cost,x0,imp=3)
 
    // External function written in C (C compiler required)
    // write down the C code (Rosenbrock problem)
    C=['#include <math.h>'
    'double sq(double x)'
    '{ return x*x;}'
    'void rosenc(int *ind, int *n, double *x, double *f, double *g, '
    '                                int *ti, float *tr, double *td)'
    '{'
    '  double p;'
    '  int i;'
    '  p=td[0];'
    '  if (*ind==2||*ind==4) {'
    '    *f=1.0;'
    '    for (i=1;i<*n;i++)'
    '      *f+=p*sq(x[i]-sq(x[i-1]))+sq(1.0-x[i]);'
    '  }'
    '  if (*ind==3||*ind==4) {'
    '    g[0]=-4.0*p*(x[1]-sq(x[0]))*x[0];'
    '    for (i=1;i<*n-1;i++)'
    '      g[i]=2.0*p*(x[i]-sq(x[i-1]))-4.0*p*(x[i+1]-sq(x[i]))*x[i]-2.0*(1.0-x[i]);'
    '    g[*n-1]=2.0*p*(x[*n-1]-sq(x[*n-2]))-2.0*(1.0-x[*n-1]);'
    '  }'
    '}'];
    mputl(C,TMPDIR+'/rosenc.c')
    // compile the C code
    l=ilib_for_link('rosenc','rosenc.o',[],'c',TMPDIR+'/Makefile');
    // incremental linking
    link(l,'rosenc','c')
    //solve the problem
    x0=[40;10;50];
    p=100;
    [f,xo,go]=optim('rosenc',x0,'td',p)

    // External function written in Fortran (Fortran compiler required)
    // write down the Fortran  code (Rosenbrock problem)
 F=[ '      subroutine rosenf(ind, n, x, f, g, ti, tr, td)'
     '      integer ind,n,ti(*)'
     '      double precision x(n),f,g(n),td(*)'
     '      real tr(*)'
     'c'
     '      double precision y,p'
     '      p=td(1)'
     '      if (ind.eq.2.or.ind.eq.4) then'
     '        f=1.0d0'
     '        do i=2,n'
     '          f=f+p*(x(i)-x(i-1)**2)**2+(1.0d0-x(i))**2'
     '        enddo'
     '      endif'
     '      if (ind.eq.3.or.ind.eq.4) then'
     '        g(1)=-4.0d0*p*(x(2)-x(1)**2)*x(1)'
     '        if(n.gt.2) then'
     '          do i=2,n-1'
     '            g(i)=2.0d0*p*(x(i)-x(i-1)**2)-4.0d0*p*(x(i+1)-x(i)**2)*x(i)'
     '     &           -2.0d0*(1.0d0-x(i))'
     '          enddo'
     '        endif'
     '        g(n)=2.0d0*p*(x(n)-x(n-1)**2)-2.0d0*(1.0d0-x(n))'
     '      endif'
     '      return'
     '      end'];

    mputl(F,TMPDIR+'/rosenf.f')
    // compile the Fortran code
    l=ilib_for_link('rosenf','rosenf.o',[],'f',TMPDIR+'/Makefile');
    // incremental linking
    link(l,'rosenf','f')
    //solve the problem
    x0=[40;10;50];
    p=100;
    [f,xo,go]=optim('rosenf',x0,'td',p)
    
  ]]></programlisting>
  </refsection>
  <refsection>
    <title>See Also</title>
    <simplelist type="inline">
      <member>
        <link linkend="external">external</link>
      </member>
      <member>
        <link linkend="quapro">quapro</link>
      </member>
      <member>
        <link linkend="linpro">linpro</link>
      </member>
      <member>
        <link linkend="datafit">datafit</link>
      </member>
      <member>
        <link linkend="leastsq">leastsq</link>
      </member>
      <member>
        <link linkend="numdiff">numdiff</link>
      </member>
      <member>
        <link linkend="derivative">derivative</link>
      </member>
      <member>
        <link linkend="NDcost">NDcost</link>
      </member>
    </simplelist>
  </refsection>
</refentry>
