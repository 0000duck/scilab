<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
 * Ajouter ici d'Ã©ventuels commentaires sur le fichier XML
-->
<refentry version="5.0-subset Scilab" xml:id="neldermead" xml:lang="fr"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:ns4="http://www.w3.org/1999/xhtml"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"
          xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <pubdate>$LastChangedDate: 16-12-2008 $</pubdate>
  </info>

  <refnamediv>
    <refname>neldermead</refname>

    <refpurpose>Provides several direct search optimization algorithms based
    on the simplex method.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>SYNOPSIS</title>

    <synopsis>
newobj = neldermead_new ()
this = neldermead_destroy (this)
this = neldermead_configure (this,key,value)
value = neldermead_cget (this,key)
this = neldermead_display ( this )
value = neldermead_get ( this , key )
this = neldermead_search ( this )
this = neldermead_restart ( this )
[ this , result ] = neldermead_function ( this , x , index )
</synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Description</title>

    <para>This class provides several direct search optimization algorithms
    based on the simplex method.</para>

    <para>The optimization problem to solve is the minimization of a cost
    function, with bounds and nonlinear constraints</para>

    <programlisting role="example"> 
min f(x)
l_i &lt;= x_i &lt;= h_i, i = 1,n
g_i(x) &lt;= 0, i = 1,nbineq
 </programlisting>

    <para>where</para>

    <variablelist>
      <varlistentry>
        <term>n</term>

        <listitem>
          <para>number of variables</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>nbineq</term>

        <listitem>
          <para>number of inequality constraints</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The provided algorithms are direct search algorithms, i.e.
    algorithms which do not use the derivative of the cost function. They are
    based on the update of a simplex, which is a set of k&gt;=n+1 vertices,
    where each vertex is associated with one point and one function
    value.</para>

    <para>The following algorithms are available :</para>

    <variablelist>
      <varlistentry>
        <term>Spendley, Hext and Himsworth fixed size simplex method</term>

        <listitem>
          <para>This algorithm solves an unconstrained optimization problem
          with a fixed sized simplex made of k=n+1 vertices.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Nelder and Mead variable size simplex method</term>

        <listitem>
          <para>This algorithm solves an unconstrained optimization problem
          with a variable sized simplex made of k=n+1 vertices.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Box complex method</term>

        <listitem>
          <para>This algorithm solves an constrained optimization problem with
          a variable sized simplex made of an arbitrary k number of vertices
          (k=2n is recommended by Box).</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>

  <refsection>
    <title>Design</title>

    <para>The neldermead component is built on top of the <link
    linkend="optimbase">optimbase</link> and <link
    linkend="optimsimplex">optimsimplex</link> components.</para>
  </refsection>

  <refsection>
    <title>Functions</title>

    <para>The following functions are available.</para>

    <variablelist>
      <varlistentry>
        <term>newobj = neldermead_new ()</term>

        <listitem>
          <para>Creates a new neldermead object.</para>

          <variablelist>
            <varlistentry>
              <term>newobj</term>

              <listitem>
                <para>The new object.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>this = neldermead_destroy (this)</term>

        <listitem>
          <para>Destroy the given object.</para>

          <variablelist>
            <varlistentry>
              <term>this</term>

              <listitem>
                <para>The current object.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>this = neldermead_configure (this,key,value)</term>

        <listitem>
          <para>Configure the current object with the given value for the
          given key.</para>

          <variablelist>
            <varlistentry>
              <term>this</term>

              <listitem>
                <para>The current object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>key</term>

              <listitem>
                <para>the key to configure. The following keys are
                available.</para>

                <variablelist>
                  <varlistentry>
                    <term>-verbose</term>

                    <listitem>
                      <para>set to 1 to enable verbose logging. (default is
                      0)</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-verbosetermination</term>

                    <listitem>
                      <para>set to 1 to enable verbose termination logging.
                      (default is 0)</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-x0</term>

                    <listitem>
                      <para>the initial guess, as a n x 1 column vector, where
                      n is the number of variables.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-maxfunevals</term>

                    <listitem>
                      <para>the maximum number of function evalutations
                      (default is 100). If this criteria is triggered, the
                      status of the optimization is set to
                      "maxfuneval".</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-maxiter</term>

                    <listitem>
                      <para>the maximum number of iterations (default is 100).
                      If this criteria is triggered, the status of the
                      optimization is set to "maxiter".</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolfunabsolute</term>

                    <listitem>
                      <para>the absolute tolerance for the function value
                      (default is 0.0).</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolfunrelative</term>

                    <listitem>
                      <para>the relative tolerance for the function value
                      (default is %eps).</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolfunmethod</term>

                    <listitem>
                      <para>the method used for the tolerance on function
                      value in the termination criteria.</para>

                      <para>The following values are available :
                      "absolute+relative", "relative", "absolute", "disabled"
                      (default is "disabled"). If this criteria is triggered,
                      the status of the optimization is set to "tolf".</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolxabsolute</term>

                    <listitem>
                      <para>the absolute tolerance on x (default is
                      0.0).</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolxrelative</term>

                    <listitem>
                      <para>the relative tolerance on x (default is
                      %eps).</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolxmethod</term>

                    <listitem>
                      <para>the method used for the tolerance on x in the
                      termination criteria.</para>

                      <para>The following values are available : "relative",
                      "absolute", "disabled" (default is "relative"). If this
                      criteria is triggered, the status of the optimization is
                      set to "tolx".</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-function</term>

                    <listitem>
                      <para>the objective function, which computes the value
                      of the cost and the non linear constraints, if
                      any.</para>

                      <para>See below for the details of the communication
                      between the optimization system and the cost
                      function.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-costfargument</term>

                    <listitem>
                      <para>an additionnal argument, passed to the cost
                      function.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-outputcommand</term>

                    <listitem>
                      <para>a command which is called back for output.</para>

                      <para>See below for the details of the communication
                      between the optimization system and the output command
                      function.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-outputcommandarg</term>

                    <listitem>
                      <para>an additionnal argument, passed to the output
                      command.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-numberofvariables</term>

                    <listitem>
                      <para>the number of variables to optimize (default is
                      0).</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-storehistory</term>

                    <listitem>
                      <para>set to 1 to enable the history storing (default is
                      0).</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-boundsmin</term>

                    <listitem>
                      <para>the minimum bounds for the parameters, as an array
                      of values (default is empty, i.e. there are no
                      bounds).</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-boundsmax</term>

                    <listitem>
                      <para>the maximum bounds for the parameters, as an array
                      of values (default is empty, i.e. there are no
                      bounds).</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-nbineqconst</term>

                    <listitem>
                      <para>the number of inequality constraints (default is
                      0)</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-method</term>

                    <listitem>
                      <para>the name of the algorithm to use. The following
                      methods are available :</para>

                      <variablelist>
                        <varlistentry>
                          <term>"fixed"</term>

                          <listitem>
                            <para>the Spendley et al. fixed simplex shape
                            algorithm. This algorithm is for unconstrained
                            problems (i.e. bounds and non linear constraints are
                            not taken into account)</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"variable"</term>

                          <listitem>
                            <para>the Nelder-Mead variable simplex shape
                            algorithm. This algorithm is for unconstrained
                            problems (i.e. bounds and non linear constraints are
                            not taken into account)</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"box"</term>

                          <listitem>
                            <para>the Box complex algorithm. This algorithm
                            takes into account bounds and nonlinear inequality
                            constraints.</para>
                          </listitem>
                        </varlistentry>
                      </variablelist>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-simplex0method</term>

                    <listitem>
                      <para>the method to use to compute the initial simplex.
                      The first vertex in the simplex is always the initial
                      guess associated with the -x0 option. The following
                      methods are available :</para>

                      <variablelist>
                        <varlistentry>
                          <term>"given"</term>

                          <listitem>
                            <para>the coordinates associated with the -coords0
                            option are used to compute the initial simplex, with
                            arbitrary number of vertices.</para>

                            <para>This allow the user to setup the initial
                            simplex by a specific method which is not provided
                            by the current component (for example with a simplex
                            computed from a design of experiments). This allows
                            also to configure the initial simplex so that a
                            specific behaviour of the algorithm an be reproduced
                            (for example the Mac Kinnon test case).</para>

                            <para>The given matrix is expected to have n rows
                            and k columns, where n is the dimension of the
                            problem and k is the number of vertices.</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"axes"</term>

                          <listitem>
                            <para>the simplex is computed from the coordinate
                            axes and the length associated with the
                            -simplex0length option.</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"spendley"</term>

                          <listitem>
                            <para>the simplex is computed so that it is regular
                            with the length associated with the -simplex0length
                            option (i.e. all the edges have the same
                            length).</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"pfeffer"</term>

                          <listitem>
                            <para>the simplex is computed from an heuristic, in
                            the neighborhood of the initial guess. This initial
                            simplex depends on the -simplex0deltausual and
                            -simplex0deltazero.</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"randbounds"</term>

                          <listitem>
                            <para>the simplex is computed from the bounds and a
                            random number. This option is available only if
                            bounds are available : if bounds are not available,
                            an error is generated. This method is usually
                            associated with Box's algorithm. The number of
                            vertices in the simplex is taken from the
                            -boxnbpoints option.</para>
                          </listitem>
                        </varlistentry>
                      </variablelist>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-coords0</term>

                    <listitem>
                      <para>the coordinates of the vertices of the initial
                      simplex. If the -simplex0method option is set to
                      "given", these coordinates are used to compute the
                      initial simplex. This matrix is expected to have shape
                      nbve x n where nbve is the number of vertices and n is
                      the number of variables.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-simplex0length</term>

                    <listitem>
                      <para>the length to use when the initial simplex is
                      computed with the "axes" or "spendley" methods. If the
                      initial simplex is computed from "spendley" method, the
                      length is expected to be a scalar value. If the initial
                      simplex is computed from "axes" method, it may be either
                      a scalar value or a vector of values, with rank n, where
                      n is the number of variables.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-simplex0deltausual</term>

                    <listitem>
                      <para>the relative delta for non-zero parameters in
                      "pfeffer" method. The default value is 0.05.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-simplex0deltazero</term>

                    <listitem>
                      <para>the absolute delta for non-zero parameters in
                      "pfeffer" method. The default value is 0.0075.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-rho</term>

                    <listitem>
                      <para>the reflection coefficient. This parameter is used
                      when the -method option is set to "fixed" or "variable".
                      The default value is 1.0.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-chi</term>

                    <listitem>
                      <para>the expansion coefficient. This parameter is used
                      when the -method option is set to "variable". The
                      default value is 2.0.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-gamma</term>

                    <listitem>
                      <para>the contraction coefficient. This parameter is
                      used when the -method option is set to "variable". The
                      default value is 0.5.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-sigma</term>

                    <listitem>
                      <para>the shrinkage coefficient. This parameter is used
                      when the -method option is set to "fixed" or "variable".
                      The default value is 0.5.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolfstdeviationmethod</term>

                    <listitem>
                      <para>set to "enabled" to enable the termination
                      criteria based on the standard deviation of the function
                      values in the simplex. The default value is "disabled".
                      If this criteria is triggered, the status of the
                      optimization is set to "tolfstdev".</para>

                      <para>This criteria is suggested by Nelder and
                      Mead.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolfstdeviation</term>

                    <listitem>
                      <para>the absolute tolerance on standard deviation. The
                      default value is 0.0.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolsimplexizemethod</term>

                    <listitem>
                      <para>set to "disabled" to disable the tolerance on the
                      simplex size. The default value is "enabled". If this
                      criteria is triggered, the status of the optimization is
                      set to "tolsize".</para>

                      <para>When this criteria is enabled, the values of the
                      options -tolsimplexizeabsolute and
                      -tolsimplexizerelative are used in the termination
                      criteria. The method to compute the size is the
                      "sigmaplus" method.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolsimplexizeabsolute</term>

                    <listitem>
                      <para>the absolute tolerance on the simplex size. The
                      default value is 0.0.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolsimplexizerelative</term>

                    <listitem>
                      <para>the relative tolerance on the simplex size. The
                      default value is %eps.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-tolssizedeltafvmethod</term>

                    <listitem>
                      <para>set to "enabled" to enable the termination
                      criteria based on the size of the simplex and the
                      difference of function value in the simplex. The default
                      value is "disabled". If this criteria is triggered, the
                      status of the optimization is set to
                      "tolsizedeltafv".</para>

                      <para>This termination criteria uses the values of the
                      options -tolsimplexizeabsolute and -toldeltafv. This
                      criteria is identical to Matlab's fminsearch.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-toldeltafv</term>

                    <listitem>
                      <para>the absolute tolerance on the difference between
                      the highest and the lowest function values.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-kelleystagnationflag</term>

                    <listitem>
                      <para>set to 1 to enable the termination criteria using
                      Kelley's stagnation detection, based on sufficient
                      decrease condition. The default value is 0. If this
                      criteria is triggered, the status of the optimization is
                      set to "kelleystagnation".</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-kelleynormalizationflag</term>

                    <listitem>
                      <para>set to 0 to disable the normalization of the alpha
                      coefficient in Kelley's stagnation detection, i.e. use
                      the value of the option -kelleystagnationalpha0 as is.
                      Default value is 1, i.e. the simplex gradient of the
                      initial simplex is taken into account in the stagnation
                      detection.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-kelleystagnationalpha0</term>

                    <listitem>
                      <para>the parameter used in Kelley's stagnation
                      detection. The default value is 1.e-4.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-restartflag</term>

                    <listitem>
                      <para>set to 1 to enable the automatic restart of the
                      algorithm. Default value is 0.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-restartdetection</term>

                    <listitem>
                      <para>the method to detect if the automatic restart must
                      be performed. The following methods are available
                      :</para>

                      <variablelist>
                        <varlistentry>
                          <term>"oneill"</term>

                          <listitem>
                            <para>the factorial local optimality test by O'Neill
                            is used. If the test finds a local point which is
                            better than the computed optimum, a restart is
                            performed.</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"kelley"</term>

                          <listitem>
                            <para>the sufficient decrease condition by O'Neill
                            is used. If the test finds that the status of the
                            optimization is "kelleystagnation", a restart is
                            performed. This status may be generated if the
                            -kelleystagnationflag option is set to 1.</para>
                          </listitem>
                        </varlistentry>
                      </variablelist>

                      <para>The default method is "oneill".</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-restartmax</term>

                    <listitem>
                      <para>the maximum number of restarts, when automatic
                      restart is enabled via the -restartflag option. Default
                      value is 3.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-restarteps</term>

                    <listitem>
                      <para>the absolute epsilon value used to check for
                      optimality in the factorial O'Neill restart detection.
                      The default value is %eps.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-restartstep</term>

                    <listitem>
                      <para>the absolute step length used to check for
                      optimality in the factorial O'Neill restart detection.
                      The default value is 1.0.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-restartsimplexmethod</term>

                    <listitem>
                      <para>the method to compute the initial simplex after a
                      restart. The following methods are available.</para>

                      <variablelist>
                        <varlistentry>
                          <term>"given"</term>

                          <listitem>
                            <para>the coordinates associated with the -coords0
                            option are used to compute the initial simplex, with
                            arbitrary number of vertices.</para>

                            <para>This allow the user to setup the initial
                            simplex by a specific method which is not provided
                            by the current component (for example with a simplex
                            computed from a design of experiments). This allows
                            also to configure the initial simplex so that a
                            specific behaviour of the algorithm an be reproduced
                            (for example the Mac Kinnon test case).</para>

                            <para>The given matrix is expected to have n rows
                            and k columns, where n is the dimension of the
                            problem and k is the number of vertices.</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"axes"</term>

                          <listitem>
                            <para>the simplex is computed from the coordinate
                            axes and the length associated with the
                            -simplex0length option.</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"spendley"</term>

                          <listitem>
                            <para>the simplex is computed so that it is regular
                            with the length associated with the -simplex0length
                            option (i.e. all the edges have the same
                            length).</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"pfeffer"</term>

                          <listitem>
                            <para>the simplex is computed from an heuristic, in
                            the neighborhood of the initial guess. This initial
                            simplex depends on the -simplex0deltausual and
                            -simplex0deltazero.</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"randbounds"</term>

                          <listitem>
                            <para>the simplex is computed from the bounds and a
                            random number. This option is available only if
                            bounds are available : if bounds are not available,
                            an error is generated. This method is usually
                            associated with Box's algorithm. The number of
                            vertices in the simplex is taken from the
                            -boxnbpoints option.</para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>"oriented"</term>

                          <listitem>
                            <para>the simplex is computed so that it is
                            oriented, as suggested by C.T. Kelley.</para>
                          </listitem>
                        </varlistentry>
                      </variablelist>

                      <para>The default method is "oriented".</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-boxnbpoints</term>

                    <listitem>
                      <para>the number of points in the initial simplex, when
                      the -restartsimplexmethod option is set to "randbounds".
                      The default value is so that the number of points is
                      twice the number of variables of the problem.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-nbineqloops</term>

                    <listitem>
                      <para>the number of loops to perform in Box and Box-Guin
                      algorithms to scale the trial point for function
                      improvement or into the constraints. Default value is
                      10.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-ineqscaling</term>

                    <listitem>
                      <para>the scaling coefficient used to scale the trial
                      point for function improvement or into the constraints.
                      Default value is 0.5</para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>value</term>

              <listitem>
                <para>the value.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>value = neldermead_cget (this,key)</term>

        <listitem>
          <para>Get the value for the given key. If the key is unknown,
          generates an error.</para>

          <variablelist>
            <varlistentry>
              <term>this</term>

              <listitem>
                <para>The current object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>key</term>

              <listitem>
                <para>the name of the key to quiery. The list of available
                keys is the same as for the neldermead_configure
                function.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>value = neldermead_get ( this , key )</term>

        <listitem>
          <para>Get the value for the given key. If the key is unknown,
          generates an error.</para>

          <variablelist>
            <varlistentry>
              <term>this</term>

              <listitem>
                <para>The current object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>key</term>

              <listitem>
                <para>the key to get.</para>

                <para>The following keys are available :</para>

                <variablelist>
                  <varlistentry>
                    <term>-funevals</term>

                    <listitem>
                      <para>the number of function evaluations</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-iterations</term>

                    <listitem>
                      <para>the number of iterations</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-xopt</term>

                    <listitem>
                      <para>the x optimum, as a n x 1 column vector, where n
                      is the number of variables.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-fopt</term>

                    <listitem>
                      <para>the optimum cost function value</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-historyxopt</term>

                    <listitem>
                      <para>an array, with nbiter values, containing the
                      history of x during the iterations.</para>

                      <para>This array is available after optimization if the
                      history storing was enabled with the -storehistory
                      option.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-historyfopt</term>

                    <listitem>
                      <para>an array, with nbiter values, containing the
                      history of the function value during the
                      iterations.</para>

                      <para>This array is available after optimization if the
                      history storing was enabled with the -storehistory
                      option.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-fx0</term>

                    <listitem>
                      <para>the function value for the initial guess</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-status</term>

                    <listitem>
                      <para>a string containing the status of the
                      optimization. See below for details about the
                      optimization status.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-historysimplex</term>

                    <listitem>
                      <para>a matrix containing the history of the simplex
                      during the iterations. This matrix has rank nbiter x
                      nbve x n, where nbiter is the number of iterations, nbve
                      is the number of vertices in the simplex and n is the
                      number of variables.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-simplex0</term>

                    <listitem>
                      <para>the initial simplex. This is a simplex object,
                      which is suitable for processing with the optimsimplex
                      component.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-simplexopt</term>

                    <listitem>
                      <para>the optimum simplex. This is a simplex object,
                      which is suitable for processing with the optimsimplex
                      component.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>-restartnb</term>

                    <listitem>
                      <para>the number of actual restarts performed.</para>
                    </listitem>
                  </varlistentry>
                </variablelist>

                <para>Most fields are available only after an optimization has
                been performed with one call to the neldermead_search
                method.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>this = neldermead_display ( this )</term>

        <listitem>
          <para>Display the current settings in the console.</para>

          <variablelist>
            <varlistentry>
              <term>this</term>

              <listitem>
                <para>The current object.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>this = neldermead_search ( this )</term>

        <listitem>
          <para>Performs the optimization associated with the method
          associated with the -method option and find the optimum.</para>

          <variablelist>
            <varlistentry>
              <term>this</term>

              <listitem>
                <para>The current object.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>If the -restartflag option is enabled, automatic restarts are
          performed, based on the -restartdetection option.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>this = neldermead_restart ( this )</term>

        <listitem>
          <para>Restarts the optimization by updating the simplex and
          performing a new search.</para>

          <variablelist>
            <varlistentry>
              <term>this</term>

              <listitem>
                <para>The current object.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>[ this , result ] = neldermead_function ( this , x , index
        )</term>

        <listitem>
          <para>Call the cost function and return the value.</para>

          <variablelist>
            <varlistentry>
              <term>this</term>

              <listitem>
                <para>The current object.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>x</term>

              <listitem>
                <para>the point where the function is to be evaluated</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>index</term>

              <listitem>
                <para>optionnal, a flag to pass to the cost function (default
                = 1). See the section "The cost function" for available values
                of index.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>

  <refsection>
    <title>The cost function</title>

    <para>The option -function allows to configure the cost function. The cost
    function is used to compute the cost and the value of the nonlinear
    inequality constraints.</para>

    <para>In the more general case, the cost function is expected to have the
    following header</para>

    <programlisting role="example"> 
function y = myfunction(x, index, data)
 </programlisting>

    <para>where</para>

    <variablelist>
      <varlistentry>
        <term>x</term>

        <listitem>
          <para>the current point</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>index</term>

        <listitem>
          <para>optional, an integer representing the value to compute</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>data</term>

        <listitem>
          <para>optional, a user-defined data.</para>

          <para>This argument is configured with the -costfargument
          option.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>y</term>

        <listitem>
          <para>the result</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The index input parameter has the following meaning</para>

    <variablelist>
      <varlistentry>
        <term>index = 1 (or no index)</term>

        <listitem>
          <para>the result is the value of the cost function</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>index = 2</term>

        <listitem>
          <para>the result is the value of the non-linear inequality
          constraints, as an array of values</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>index = 3</term>

        <listitem>
          <para>the result is an array, which content is the following. At
          index #1, the value of the cost function. At index #2 to the end,
          the list of values of the nonlinear inequality constraints.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>In the most simple case, the cost function is expected to have the
    following header</para>

    <programlisting role="example"> 
function y = myfunction(x)
 </programlisting>

    <para>where x is the current point and y is the value of the cost. This
    case is associated with an unconstrained problem without any additionnal
    parameter.</para>
  </refsection>

  <refsection>
    <title>The output function</title>

    <para>The option -outputcommand allows to configure a command which is
    called back at the start of the optimization, at each iteration and at the
    end of the optimization.</para>

    <para>The output function must have the following header</para>

    <programlisting role="example"> 
function outputcmd(state, data, myobj)
 </programlisting>

    <para>where</para>

    <variablelist>
      <varlistentry>
        <term>state</term>

        <listitem>
          <para>a string representing the current state of the algorithm.
          Available values are "init", "iter", "done".</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>data</term>

        <listitem>
          <para>a tlist containing at least the following entries</para>

          <variablelist>
            <varlistentry>
              <term>x</term>

              <listitem>
                <para>the current optimum</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>fval</term>

              <listitem>
                <para>the current function value</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>iteration</term>

              <listitem>
                <para>the current iteration index</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>funccount</term>

              <listitem>
                <para>the number of function evaluations</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>simplex</term>

              <listitem>
                <para>the current simplex</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>step</term>

              <listitem>
                <para>the previous step in the algorithm. The following values
                are available : "init", "done", "reflection", "expansion",
                "insidecontraction", "outsidecontraction", "reflectionnext",
                "shrink".</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>myobj</term>

        <listitem>
          <para>a user-defined parameter.</para>

          <para>This input parameter is defined with the -outputcommandarg
          option.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The output function may be used when debugging the specialized
    optimization algorithm, so that a verbose logging is produced. It may also
    be used to write one or several report files in a specialized format
    (ASCII, LaTeX, Excel, Hdf5, etc...). The user-defined parameter may be
    used in that case to store file names or logging options.</para>

    <para>The data tlist argument may contain more fields than the current
    presented ones. These additionnal fields may contain values which are
    specific to the specialized algorithm, such as the simplex in a
    Nelder-Mead method, the gradient of the cost function in a BFGS method,
    etc...</para>
  </refsection>

  <refsection>
    <title>Termination</title>

    <para>The current component takes into account for several generic
    termination criterias. Specialized termination criterias should be
    implemented in specialized optimization algorithms, by calling the
    optimization_termination function and adding external criterias, rather
    than by modification of this function.</para>

    <para>The optimization_terminate function uses a set of rules to compute
    if the termination occurs, which leads to an optimization status which is
    equal to one of the following : "continue", "maxiter", "maxfunevals",
    "tolf", "tolx", "tolfstdev", "tolsize", "tolsizedeltafv",
    "kelleystagnation". The set of rules is the following.</para>

    <itemizedlist>
      <listitem>
        <para>By default, the status is "continue" and the terminate flag is
        0.</para>
      </listitem>

      <listitem>
        <para>The number of iterations is examined and compared to the
        -maxiter option : if the following condition</para>

        <programlisting role="example"> 
iterations &gt;= maxiter
 </programlisting>

        <para>is true, then the status is set to "maxiter" and terminate is
        set to 1.</para>
      </listitem>

      <listitem>
        <para>The number of function evaluations and compared to the
        -maxfunevals option is examined : if the following condition</para>

        <programlisting role="example"> 
funevals &gt;= maxfunevals
 </programlisting>

        <para>is true, then the status is set to "maxfuneval" and terminate is
        set to 1.</para>
      </listitem>

      <listitem>
        <para>The tolerance on function value is examined depending on the
        value of the -tolfunmethod.</para>

        <variablelist>
          <varlistentry>
            <term>"disabled"</term>

            <listitem>
              <para>then the criteria is just ignored.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>"enabled"</term>

            <listitem>
              <para>if the following condition</para>

              <programlisting role="example"> 
abs(currentfopt) &lt; tolfunrelative * abs(previousfopt) + tolfunabsolute
 </programlisting>

              <para>is true, then the status is set to "tolf" and terminate is
              set to 1.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The relative termination criteria on the function value works
        well if the function value at optimum is near zero. In that case, the
        function value at initial guess fx0 may be used as
        previousfopt.</para>

        <para>The absolute termination criteria on the function value works if
        the user has an accurate idea of the optimum function value.</para>
      </listitem>

      <listitem>
        <para>The tolerance on x is examined depending on the value of the
        -tolxmethod.</para>

        <variablelist>
          <varlistentry>
            <term>"disabled"</term>

            <listitem>
              <para>then the criteria is just ignored.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>"enabled"</term>

            <listitem>
              <para>if the following condition</para>

              <programlisting role="example"> 
norm(currentxopt - previousxopt) &lt; tolxrelative * norm(currentxopt) + tolxabsolute
 </programlisting>

              <para>is true, then the status is set to "tolx" and terminate is
              set to 1.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The relative termination criteria on the function value works
        well if x at optimum is different from zero. In that case, the
        condition measures the distance between two iterates.</para>

        <para>The absolute termination criteria on the function value works if
        the user has an accurate idea of the scale of the optimum x. If the
        optimum x is near 0, the relative tolerance will not work and the
        absolute tolerance is more appropriate.</para>
      </listitem>

      <listitem>
        <para>The absolute tolerance on standard deviation of the function
        value is examined depending on the value of the -tolfstdeviationmethod
        option.</para>

        <variablelist>
          <varlistentry>
            <term>"disabled"</term>

            <listitem>
              <para>then the criteria is just ignored.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>"enabled"</term>

            <listitem>
              <para>if the following condition</para>

              <programlisting role="example"> 
st_deviation(fv) &lt; tolfstdeviation
 </programlisting>

              <para>is true where fv is an array containing the function
              values in the simplex, then the status is set to "tolfstdev" and
              terminate is set to 1.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </listitem>

      <listitem>
        <para>The absolute tolerance on simplex size is examined depending on
        the value of the -tolsimplexizemethod option.</para>

        <variablelist>
          <varlistentry>
            <term>"disabled"</term>

            <listitem>
              <para>then the criteria is just ignored.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>"enabled"</term>

            <listitem>
              <para>if the following condition</para>

              <programlisting role="example"> 
ssize &lt; tolsimplexizerelative * simplexsize0 + tolsimplexizeabsolute
 </programlisting>

              <para>is true where simplexsize0 is the size of the simplex at
              iteration 0, then the status is set to "tolsize" and terminate
              is set to 1.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </listitem>

      <listitem>
        <para>The absolute tolerance on simplex size and absolute difference
        of function value is examined depending on the value of the
        -tolssizedeltafvmethod option.</para>

        <variablelist>
          <varlistentry>
            <term>"disabled"</term>

            <listitem>
              <para>then the criteria is just ignored.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>"enabled"</term>

            <listitem>
              <para>if both the following conditions</para>

              <programlisting role="example"> 
ssize &lt; tolsimplexizeabsolute 
 </programlisting>

              <programlisting role="example"> 
shiftfv &lt; toldeltafv
 </programlisting>

              <para>is true where ssize is the current simplex size and
              shiftfv is the absolute value of the difference of function
              value between the highest and lowest vertices, then the status
              is set to "tolsizedeltafv" and terminate is set to 1.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </listitem>

      <listitem>
        <para>The stagnation condition based on Kelley sufficient decrease
        condition is examined depending on the value of the
        -kelleystagnationflag option.</para>

        <variablelist>
          <varlistentry>
            <term>"disabled"</term>

            <listitem>
              <para>then the criteria is just ignored.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>"enabled"</term>

            <listitem>
              <para>if the following condition</para>

              <programlisting role="example"> 
newfvmean &lt;= oldfvmean - alpha * sg' * sg
 </programlisting>

              <para>is true where newfvmean (resp. oldfvmean) is the function
              value average in the current iteration (resp. in the previous
              iteration), then the status is set to "kelleystagnation" and
              terminate is set to 1. Here, alpha is a non-dimensional
              coefficient and sg is the simplex gradient.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </listitem>
    </itemizedlist>
  </refsection>

  <refsection>
    <title>Kelley's stagnation detection</title>

    <para>The stagnation detection criteria suggested by Kelley is based on a
    sufficient decrease condition, which requires a parameter alpha &gt; 0 to
    be defined. The -kelleynormalizationflag option allows to configure the
    method to use to compute this alpha parameter : two methods are available,
    where each method corresponds to a different paper by Kelley :</para>

    <variablelist>
      <varlistentry>
        <term>constant</term>

        <listitem>
          <para>In "Detection and Remediation of Stagnation in the
          Nelder--Mead Algorithm Using a Sufficient Decrease Condition",
          Kelley uses a constant alpha, with the suggested value 1.e-4, which
          is is typical choice for line search method.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>normalized</term>

        <listitem>
          <para>in "Iterative Methods for Optimization", Kelley uses a
          normalized alpha, computed from the following formula</para>

          <programlisting role="example"> 
alpha = alpha0 * sigma0 / nsg
 </programlisting>

          <para>where sigma0 is the size of the initial simplex and nsg is the
          norm of the simplex gradient for the initial guess point.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>

  <refsection>
    <title>O'Neil factorial optimality test</title>

    <para>In "Algorithm AS47 - Function minimization using a simplex
    procedure", R. O'Neil presents a fortran 77 implementation of the simplex
    method. A factorial test is used to check if the computed optimum point is
    a local minimum. If the -restartdetection option is set to "oneill", that
    factorial test is used to see if a restart should be performed.</para>
  </refsection>

  <refsection>
    <title>Spendley et al. implementation notes</title>

    <para>The original paper may be implemented with several variations, which
    might lead to different results. This section defines what algorithmic
    choices have been used.</para>

    <para>The paper states the following rules.</para>

    <itemizedlist>
      <listitem>
        <para>"Rule 1. Ascertain the lowest reading y, of yi ... yk+1 Complete
        a new simplex Sp by excluding the point Vp corresponding to y, and
        replacing it by V* defined as above."</para>
      </listitem>

      <listitem>
        <para>"Rule 2. If a result has occurred in (k + 1) successive
        simplexes, and is not then eliminated by application of Rule 1, do not
        move in the direction indicated by Rule 1, or at all, but discard the
        result and replace it by a new observation at the same point."</para>
      </listitem>

      <listitem>
        <para>"Rule 3. If y is the lowest reading in So , and if the next
        observation made, y* , is the lowest reading in the new simplex S , do
        not apply Rule 1 and return to So from Sp . Move out of S, by
        rejecting the second lowest reading (which is also the second lowest
        reading in So)."</para>
      </listitem>
    </itemizedlist>

    <para>We implement the following "rules" of the Spendley et al.
    method.</para>

    <itemizedlist>
      <listitem>
        <para>Rule 1 is strictly applied, but the reflection is done by
        reflection the high point, since we minimize a function instead of
        maximizing it, like Spendley.</para>
      </listitem>

      <listitem>
        <para>Rule 2 is NOT implemented, as we expect that the function
        evaluation is not subject to errors.</para>
      </listitem>

      <listitem>
        <para>Rule 3 is applied, ie reflection with respect to next to high
        point.</para>
      </listitem>
    </itemizedlist>

    <para>The original paper does not mention any shrink step. When the
    original algorithm cannot improve the function value with reflection
    steps, the basic algorithm stops. In order to make the current
    implementation of practical value, a shrink step is included, with
    shrinkage factor sigma. This perfectly fits into to the spirit of the
    original paper. Notice that the shrink step make the rule #3 (reflection
    with respect to next-to-worst vertex) unnecessary. Indeed, the minimum
    required steps are the reflection and shrinkage. Never the less, the rule
    #3 has been kept in order to make the algorithm as close as it can be to
    the original.</para>
  </refsection>

  <refsection>
    <title>Example #1</title>

    <para>In the following example, we solve the Rosenbrock test case. We
    begin by defining the Rosenbrock function, which takes 2 input arguments
    and returns the objective. The classical starting point [-1.2 1.0] is
    used. The neldermead_new creates a new neldermead object. Then we use the
    neldermead_configure method to configure the parameters of the problem.
    The initial simplex is computed from the axes and the single length 1.0
    (this is the default, but is explicitely written here as an example). The
    variable simplex algorithm by Nelder and Mead is used, which corresponds
    to the -method "variable" option. The neldermead_search function performs
    the search for the minimum. Once the minimum is found, the
    neldermead_contour allows to compute the data required by the contour
    function. This is possible since our problem involves only 2 parameters.
    This function uses the cost function previously configured to compute the
    required data. The contour plot is directly drawn from the data provided
    by neldermead_contour. Then we plot the initial guess on the contour plot
    as a blue dot. The neldermead_get function is used to get the optimum,
    which is associated with the -xopt option. The optimum is plot on the
    contour plot as a red dot.</para>

    <programlisting role="example">
mprintf("Defining Rosenbrock function...\n");
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2+(1-x(1))^2;
endfunction
x0 = [-1.2 1.0]';
mprintf("x0=%s\n",strcat(string(x0)," "));
mprintf("Creating object...\n");
nm = neldermead_new ();
mprintf("Configuring object...\n");
nm = neldermead_configure(nm,"-numberofvariables",2);
nm = neldermead_configure(nm,"-function",rosenbrock);
nm = neldermead_configure(nm,"-x0",x0);
nm = neldermead_configure(nm,"-maxiter",200);
nm = neldermead_configure(nm,"-maxfunevals",300);
nm = neldermead_configure(nm,"-tolfunrelative",10*%eps);
nm = neldermead_configure(nm,"-tolxrelative",10*%eps);
nm = neldermead_configure(nm,"-simplex0method","axes");
nm = neldermead_configure(nm,"-simplex0length",1.0);
nm = neldermead_configure(nm,"-method","variable");
nm = neldermead_configure(nm,"-verbose",0);
nm = neldermead_configure(nm,"-verbosetermination",0);
mprintf("Searching for minimum...\n");
nm = neldermead_search(nm);
mprintf("Plot contour...\n");
xmin = -2.0 ; xmax = 2.0 ; ymin = -2.0 ; ymax = 2.0 ; nx = 100 ; ny = 100;
stepx = (xmax - xmin)/nx
xdata = xmin:stepx:xmax;
stepy = (ymax - ymin)/ny
ydata = ymin:stepy:ymax;
for ix = 1:length(xdata)
  for iy = 1:length(ydata)
    experiment = [xdata(ix) ydata(iy)];
    [ nm , fiexp ] = neldermead_function ( nm , experiment );
    zdata ( ix , iy ) = fiexp;
  end
end
wnum = 100001;
my_handle             = scf(wnum);
contour ( xdata , ydata , zdata , [1 10 100 500 1000 2000] )
// Plot starting point
mprintf("x0 : blue dot\n");
plot(x0(1),x0(2));
my_handle.children.children(1).children.mark_mode="on";
my_handle.children.children(1).children.mark_size = 5;
my_handle.children.children(1).children.mark_foreground = 2;
mprintf("xopt : red dot\n");
xopt = neldermead_get(nm,"-xopt");
plot(xopt(1),xopt(2));
my_handle.children.children(1).children.mark_mode="on";
my_handle.children.children(1).children.mark_size = 5;
my_handle.children.children(1).children.mark_foreground = 5;

nm = neldermead_destroy(nm);
</programlisting>

    <para>The -verbose option allows to get detailed informations about the
    current optimization process. The following is a sample output for an
    optimization based on the Nelder and Mead variable-shape simplex
    algorithm. Only the output corresponding to the iteration #156 is
    displayed. In order to display specific outputs (or to create specific
    output files and graphics), the -outputcommand option should be
    used.</para>

    <programlisting role="example">
=================================================================
Iteration #156 (total = 156)
Function Eval #297
Xopt : 1 1
Fopt : 6.871176e-027
DeltaFv : 2.880999e-026
Center : 1 1
Size : 2.548515e-013
Vertex #1/3 : fv=0.000000, x=1.000000 1.000000
Vertex #2/3 : fv=0.000000, x=1.000000 1.000000
Vertex #3/3 : fv=0.000000, x=1.000000 1.000000
nmplot_outputcmd (1)
Reflect
xbar=1 1
Function Evaluation #298 is [1.155D-25] at [1 1]
xr=[1 1], f(xr)=0.000000
Contract - inside
Function Evaluation #299 is [6.023D-27] at [1 1]
xc=1 1, f(xc)=0.000000
  &gt; Perform Inside Contraction
Sort
</programlisting>
  </refsection>

  <refsection>
    <title>Example #2</title>

    <para>In the following example, we show how to use the output command to
    create specialized outputs. These outputs may be used to create specific
    data files or make interactive graphic outputs.</para>

    <para>We define the function "myoutputcmd", which takes the current state
    as its first argument. The state is a string which can contain "init",
    "iter" or "done", depending on the status of the optimization. The data
    input argument is a tlist, which contains the data associated with the
    current iteration. In this case, we use the fields to print a message in
    the console. As another example of use, we could format the message so
    that it uses LaTeX formatting rules, which may allow the user to directly
    copy and paste the output into a LaTeX report.</para>

    <programlisting role="example">
function y = rosenbrock (x)
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction


//
// myoutputcmd --
//  This command is called back by the Nelder-Mead
//  algorithm.
// Arguments
//  state : the current state of the algorithm
//    "init", "iter", "done"
//  data : the data at the current state
//
function myoutputcmd ( state , data )
  iter = data.iteration
  if ( state == "init" ) then
    mprintf ( "=================================\n");
    mprintf ( "Initialization\n");
  elseif ( state == "done" ) then
    mprintf ( "=================================\n");
    mprintf ( "End of Optimization\n");
  end
  fc = data.funccount
  fval = data.fval
  x = data.x
  simplex = data.simplex
  // Simplex is a data structure, which can be managed
  // by the optimsimplex class.
  ssize = optimsimplex_size ( simplex )
  mprintf ( "Iteration #%d, Feval #%d, Fval = %e, x = %s, Size = %e\n", iter, fc, fval, strcat(string(x)," "), ssize);
endfunction


nm = neldermead_new ();
nm = neldermead_configure(nm,"-numberofvariables",2);
nm = neldermead_configure(nm,"-function",rosenbrock);
nm = neldermead_configure(nm,"-x0",[-1.2 1.0]');
nm = neldermead_configure(nm,"-maxiter",200);
nm = neldermead_configure(nm,"-maxfunevals",300);
nm = neldermead_configure(nm,"-tolfunrelative",10*%eps);
nm = neldermead_configure(nm,"-tolxrelative",10*%eps);
nm = neldermead_configure(nm,"-simplex0method","axes");
nm = neldermead_configure(nm,"-simplex0length",1.0);
nm = neldermead_configure(nm,"-method","variable");
nm = neldermead_configure(nm,"-verbose",0);
nm = neldermead_configure(nm,"-verbosetermination",0);
nm = neldermead_configure(nm,"-outputcommand",myoutputcmd);
nm = neldermead_search(nm);
nm = neldermead_destroy(nm);
</programlisting>

    <para>The previous script produces the following output.</para>

    <programlisting role="example">
=================================
Initialization
Iteration #0, Feval #4, Fval = 2.420000e+001, x = -1.2 1, Size = 1.000000e+000
Iteration #1, Feval #4, Fval = 2.420000e+001, x = -1.2 1, Size = 1.000000e+000
Iteration #2, Feval #6, Fval = 2.420000e+001, x = -1.2 1, Size = 1.000000e+000
Iteration #3, Feval #8, Fval = 2.420000e+001, x = -1.2 1, Size = 1.000000e+000
Iteration #4, Feval #10, Fval = 9.999182e+000, x = -1.0125 0.78125, Size = 5.970304e-001
...
Iteration #155, Feval #296, Fval = 2.024754e-026, x = 1 1, Size = 4.601219e-013
Iteration #156, Feval #298, Fval = 6.871176e-027, x = 1 1, Size = 2.548515e-013
Iteration #157, Feval #300, Fval = 6.023002e-027, x = 1 1, Size = 2.814328e-013
=================================
End of Optimization
Iteration #157, Feval #300, Fval = 6.023002e-027, x = 1 1, Size = 2.814328e-013
</programlisting>
  </refsection>

  <refsection>
    <title>TODO</title>

    <itemizedlist>
      <listitem>
        <para>Add the Box-Guin algoritm as a 4th method.</para>

        <para>This algorithm solves an constrained optimization problem with a
        variable sized simplex made of an arbitrary k number of vertices. This
        is an update of Box's algorithm.</para>
      </listitem>

      <listitem>
        <para>Add the optimization of the Rosenbrock test case, with the
        interactive plot thanks to the -outputcommand option.</para>
      </listitem>

      <listitem>
        <para>Add an option to let the user setup his own termination
        criteria.</para>

        <para>This might be handy in case where the user try to reproduce the
        behaviour of another algorithm (be it a software or a paper), where
        none of the provided termination criteria match the required one. This
        feature would allow to use our own termination criteria, without
        modifying the internal source code of the component. This might be
        dangerous if the user does not clearly understand what is going on.
        But that might be very handy as well.</para>
      </listitem>
    </itemizedlist>
  </refsection>

  <refsection>
    <title>Bibliography</title>

    <para>"Sequential Application of Simplex Designs in Optimisation and
    Evolutionary Operation", Spendley, W. and Hext, G. R. and Himsworth, F.
    R., American Statistical Association and American Society for Quality,
    1962</para>

    <para>"A Simplex Method for Function Minimization", Nelder, J. A. and
    Mead, R., The Computer Journal, 1965</para>

    <para>"A New Method of Constrained Optimization and a Comparison With
    Other Methods", M. J. Box, The Computer Journal 1965 8(1):42-52, 1965 by
    British Computer Society</para>

    <para>"Discussion and correspondence: modification of the complex method
    of constrained optimization", J. A. Guin, The Computer Journal,
    1968</para>

    <para>"Detection and Remediation of Stagnation in the Nelder--Mead
    Algorithm Using a Sufficient Decrease Condition", Kelley C. T., SIAM J. on
    Optimization, 1999</para>

    <para>"Iterative Methods for Optimization", C. T. Kelley, SIAM Frontiers
    in Applied Mathematics, 1999</para>

    <para>"Algorithm AS47 - Function minimization using a simplex procedure",
    O'Neill, R., Applied Statistics, 1971</para>
  </refsection>

  <refsection>
    <title>Authors</title>

    <para>Michael Baudin - INRIA - 2008-2009</para>

    <para>Michael Baudin - Digiteo - 2009</para>
  </refsection>

  <refsection>
    <title>See Also</title>

    <simplelist type="inline">
      <member><link linkend="optimbase">optimbase</link></member>

      <member><link linkend="optimsimplex">optimsimplex</link></member>

      <member><link linkend="optimsimplex">nmplot</link></member>
    </simplelist>
  </refsection>
</refentry>
