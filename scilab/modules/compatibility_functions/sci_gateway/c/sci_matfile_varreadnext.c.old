/*
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA - Vincent COUVERT 
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 */

#include "matfile_manager.h"
#include "MALLOC.h"
#include "stack-c.h" /* stack-def.h, stack1.h, stack2.h, stack3.h included */
#include "gw_matio.h"
#include "localization.h"
#include "Scierror.h"
#include "sciprint.h"

/* SCILAB INTEGER TYPES */
enum scilab_integer_type {
  SCILAB_INT8 = 1,
  SCILAB_INT16 = 2,
  SCILAB_INT32 = 4,
  SCILAB_UINT8 = 11,
  SCILAB_UINT16 = 12,
  SCILAB_UINT32 = 14};

enum matfile_errors {
  NO_MORE_VARIABLES = -1,
  UNKNOWN_VARIABLE_TYPE = 0};


int CreateHyperMatrixVariable(int number, char *type, int *iscomplex, int * rank, int *dims, double *realdata, double *complexdata);
int CreateIntegerVariable(int integerType, matvar_t *matVariable);
int CreateStructVariable(int *number, matvar_t *matVariable);

int sci_matfile_varreadnext(char *fname,unsigned long fname_len)
{
  int nbRow = 0, nbCol = 0, stkAdr = 0;

  mat_t *matfile = NULL;

  matvar_t *matvar = NULL;

  int fileIndex = 0;

  char *varname = NULL;
  int varnameAdr = 0;
  int valueAdr = 0;
  int classAdr = 0;

  double * complexData = NULL;

  int variableIndex = 0;

  int returnedClass = 0;

  CheckRhs(1, 1);
  CheckLhs(1, 3);

  /* Input argument is the index of the file to read */
  if (VarType(1) == sci_matrix)
    {
      GetRhsVar(1, MATRIX_OF_DOUBLE_DATATYPE, &nbRow, & nbCol, &stkAdr);
      if (nbRow * nbCol != 1)
        {
          Scierror(999, _("%s: Wrong size for first input argument: Single double expected.\n"), fname);
          return FALSE;
        }
      fileIndex = *stk(stkAdr);
    }
  else
    {
      Scierror(999, _("%s: Wrong type for first input argument: Double expected.\n"), fname);
      return FALSE;
    }

  /* Gets the corresponding matfile */
  matfile_manager(MATFILEMANAGER_GETFILE, &fileIndex, &matfile);

  matvar = Mat_VarReadNext(matfile);
  if ((matvar == NULL) || (matvar->name == NULL))
    {
      sciprint("End of file\n");
      /* Return empty name */
      nbRow = 0; nbCol = 0;
      CreateVar(Rhs+1, STRING_DATATYPE, &nbRow, &nbCol, &varnameAdr);

      /* Return empty value */
      nbRow = 0; nbCol = 0;
      CreateVar(Rhs+2, MATRIX_OF_DOUBLE_DATATYPE, &nbRow, &nbCol, &valueAdr);
      
      /* Return error flag instead of variable class */
      nbRow = 1; nbCol = 1;
      CreateVar(Rhs+3, MATRIX_OF_DOUBLE_DATATYPE, &nbRow, &nbCol, &classAdr);
      *stk(classAdr) = NO_MORE_VARIABLES;
      
      LhsVar(1) = Rhs + 1;
      LhsVar(2) = Rhs + 2;
      LhsVar(3) = Rhs + 3;
      PutLhsVar();

      return TRUE;
    }
  
  /* Return the variable name */
  varname = strdup(matvar->name);
  nbRow = strlen(varname);
  nbCol = 1;
  CreateVarFromPtr(Rhs + 1, STRING_DATATYPE, &nbRow, &nbCol, &varname);

  returnedClass = matvar->class_type;

  /* Return the values */
  sciprint("Read a variable of class %d.\n", matvar->class_type);
  switch(matvar->class_type)
    {
    case MAT_C_STRUCT: /* 2 */
      sciprint("struct struct\n");
      variableIndex = Rhs + 2;
      CreateStructVariable(&variableIndex, matvar);
      break;
    case MAT_C_DOUBLE: /* 6 */
      if(matvar->rank==2) /* 2-D array */
        {
          nbRow = matvar->dims[0];
          nbCol = matvar->dims[1];
          if (matvar->isComplex == 0)
            {
              CreateVarFromPtr(Rhs+2, MATRIX_OF_DOUBLE_DATATYPE, &nbRow, &nbCol, &matvar->data);
            }
          else
            {
              complexData = &(matvar->data)[nbRow*nbCol];
              CreateCVarFromPtr(Rhs+2, MATRIX_OF_DOUBLE_DATATYPE, &matvar->isComplex, &nbRow, &nbCol, &matvar->data, &complexData);
            }
        }
      else /* Multi-dimension array -> Scilab HyperMatrix */
        {
          if (matvar->isComplex == 0)
            {
              CreateHyperMatrixVariable(Rhs + 2, MATRIX_OF_DOUBLE_DATATYPE,  &matvar->isComplex, &matvar->rank, matvar->dims, matvar->data, NULL);
            }
          else
            {
              CreateHyperMatrixVariable(Rhs + 2, MATRIX_OF_DOUBLE_DATATYPE,  &matvar->isComplex, &matvar->rank, matvar->dims, matvar->data, &(matvar->data[nbRow*nbCol]));
            }
        }
      break;
    case MAT_C_INT8: /* 8 */
      CreateIntegerVariable(SCILAB_INT8, matvar);
      break;
    case MAT_C_UINT8: /* 9 */
      CreateIntegerVariable(SCILAB_UINT8, matvar);
      break;
    case MAT_C_INT16: /* 10 */
      CreateIntegerVariable(SCILAB_INT16, matvar);
      break;
    case MAT_C_UINT16: /* 11 */
      CreateIntegerVariable(SCILAB_UINT16, matvar);
      break;
    case MAT_C_INT32: /* 12 */
      CreateIntegerVariable(SCILAB_INT32, matvar);
      break;
    case MAT_C_UINT32: /* 13 */
      CreateIntegerVariable(SCILAB_UINT32, matvar);
      break;
    case MAT_C_CELL: /* 1 to be written */
    case MAT_C_OBJECT: /* 3 to be written */
    case MAT_C_CHAR: /* 4 BUG */
    case MAT_C_SPARSE: /* 5 to be written */
    case MAT_C_SINGLE: /* 7 to be written */
    case MAT_C_INT64: /* 14: no Scilab equivalent */
    case MAT_C_UINT64: /* 15: no Scilab equivalent */
    case MAT_C_FUNCTION: /* 16 to be written */
    default:
      sciprint("Do not know how to read a variable of class %d.\n", matvar->class_type);
      nbRow = 0; nbCol = 0;
      CreateVar(Rhs+2, MATRIX_OF_DOUBLE_DATATYPE, &nbRow, &nbCol, &valueAdr);
      returnedClass = UNKNOWN_VARIABLE_TYPE;
      break;
    }

  /* Create class return value */
  nbRow = 1; nbCol = 1;
  CreateVar(Rhs + 3, MATRIX_OF_DOUBLE_DATATYPE, &nbRow, &nbCol, &classAdr);
  *stk(classAdr) = returnedClass;

  LhsVar(1) = Rhs + 1;
  LhsVar(2) = Rhs + 2;
  LhsVar(3) = Rhs + 3;
  PutLhsVar();

  Mat_VarFree(matvar);
  FREE(varname);

  return TRUE;
}

int CreateHyperMatrixVariable(int number, char *type, int *iscomplex, int * rank, int *dims, double *realdata, double *complexdata)
{
  static char *tlistFields[] = {"hm", "dims","entries"};

  int tlistSize = 3;

  int nbRow = 0, nbCol = 0;

  int K = 0;

  SciIntMat integerMatrix;

  /* mlist fields */
  nbRow = 1;
  nbCol = 3;
  CreateVarFromPtr(number, MATRIX_OF_STRING_DATATYPE, &nbRow, &nbCol, &tlistFields);

  /* hm dimensions */
  nbRow = 1;
  CreateVarFromPtr(number + 1, MATRIX_OF_INTEGER_DATATYPE, &nbRow, rank, &dims);

  /* hm entries */
  nbRow = 1;
  for (K=0; K<*rank; K++)
    {
      nbRow *= dims[K];
    }

  nbCol = 1;
  
  if (type==MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE)
    {
      integerMatrix.D = realdata;
      integerMatrix.it = *iscomplex;
      integerMatrix.m = nbRow;
      integerMatrix.n = nbCol;
      CreateVarFromPtr(number + 2, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE, &nbRow, &nbCol, &integerMatrix);
    }
  else
    {
       if (iscomplex == 0)
        {
          CreateVarFromPtr(number + 2, MATRIX_OF_DOUBLE_DATATYPE, &nbRow, &nbCol, &realdata);
        }
      else
        {
          CreateCVarFromPtr(number + 2, MATRIX_OF_DOUBLE_DATATYPE, iscomplex, &nbRow, &nbCol, &realdata, &complexdata);
        }
    }

  C2F(mkmlistfromvars)(&number, &tlistSize);

  return TRUE;
}

int CreateIntegerVariable(int integerType, matvar_t *matVariable)
{
  SciIntMat integerMatrix;

  // Integer Type
  integerMatrix.it = integerType;
  
  // Matrix dimensions
  integerMatrix.m = matVariable->dims[0];
  integerMatrix.n = matVariable->dims[1];

  // Matrix data
  integerMatrix.D = matVariable->data;

  if(matVariable->rank==2) /* 2-D array */
    {
      CreateVarFromPtr(Rhs + 2, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE, &integerMatrix.m, &integerMatrix.n, &integerMatrix);
    }
  else /* Multi-dimension array -> Scilab HyperMatrix */
    {
      CreateHyperMatrixVariable(Rhs + 2, MATRIX_OF_VARIABLE_SIZE_INTEGER_DATATYPE,  &integerMatrix.it, &matVariable->rank, matVariable->dims, matVariable->data, NULL);
    }
  
  return TRUE;
}

int CreateStructVariable(int *number, matvar_t *matVariable)
{
  char **fieldNames = NULL;
  int nbFields = 0;
  int allocSize = 0;
  int nbRow = 0;
  int nbCol = 0;
  int valueAdr = 0;
  int fieldIndex = 0;
  int K = 0;
  int prodDims = 0;
  int listAdr = 0;
  int valueIndex = 0;
  matvar_t *fieldMatVar = NULL;
  int sizeOfList = 0;

  int noValue = -1;

  /* Fields of the struct */
  nbFields = 2; /* "st" "dims" */
  nbFields += Mat_VarGetNumberOfFields(matVariable);

  fieldNames = (char**) MALLOC(sizeof(char*) * nbFields);
  if (fieldNames==NULL)
    {
      Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
      return FALSE;
    }
  
  fieldNames[0] = strdup("st");
  if (fieldNames[0]==NULL)
    {
      Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
      return FALSE;
    }
  fieldNames[1] = strdup("dims");
  if (fieldNames[1]==NULL)
    {
      Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
      return FALSE;
    }
  
  for (fieldIndex = 1; fieldIndex < nbFields - 1; fieldIndex++)
    {
      fieldMatVar = Mat_VarGetStructField(matVariable, &fieldIndex, BY_INDEX, 0);
      fieldNames[fieldIndex + 1] = strdup(fieldMatVar->name);
      if (fieldNames[fieldIndex + 1]==NULL)
        {
          Scierror(999, _("%s: No more memory.\n"), "CreateStructVariable");
          return FALSE;
        }
    }

  nbRow = 1;
  CreateVarFromPtr(*number, MATRIX_OF_STRING_DATATYPE, &nbRow, &nbFields, fieldNames);

  /* Dimensions */
  nbRow = 1;
  CreateVarFromPtr(*number + 1, MATRIX_OF_INTEGER_DATATYPE, &nbRow, &matVariable->rank, &matVariable->dims);

  /* Create fields data */
  prodDims = 1;
  for (K=0; K<matVariable->rank; K++)
    {
      prodDims *= matVariable->dims[K];
    }
  sciprint("Prod of dims = %d\n", prodDims);

  if (prodDims == 1) /* Scalar struct */
    {
      nbRow = 0;
      nbCol = 0;
      for (fieldIndex = 0; fieldIndex < nbFields - 2; fieldIndex++)
        {
          CreateVar(*number + 2 + fieldIndex, MATRIX_OF_DOUBLE_DATATYPE, &nbRow, &nbCol, &valueAdr);
        }
    }
  else
    {
      listAdr = *number + 2;
      /* Empty matrices */
      nbRow = 0;
      nbCol = 0;
      for (valueIndex = 0; valueIndex < prodDims; valueIndex++)
        {
          sizeOfList = nbFields - 2;
          C2F(createlist)(&listAdr, &sizeOfList);
          for (fieldIndex = 1; fieldIndex < nbFields - 1; fieldIndex++)
            {
              C2F(createlistvarfrom)(&listAdr, &fieldIndex, MATRIX_OF_DOUBLE_DATATYPE, &nbRow, &nbCol, &valueAdr,&noValue,1);
            }
          listAdr++;
        }
      
      
    }
  C2F(mkmlistfromvars)(number, &nbFields);

      
  freeArrayOfString(fieldNames);

  return TRUE;
}
