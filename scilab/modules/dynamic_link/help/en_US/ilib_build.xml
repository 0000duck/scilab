<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) INRIA - 
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry version="5.0-subset Scilab" xml:id="ilib_build" xml:lang="en"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:ns4="http://www.w3.org/1999/xhtml"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"
          xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <pubdate>$LastChangedDate: 2006-09-03 11:54:48 +0200 (Sun, 03 Sep 2006)
    $</pubdate>
  </info>

  <refnamediv>
    <refname>ilib_build</refname>

    <refpurpose>utility for shared library management</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>Calling Sequence</title>

    <synopsis>ilib_build(lib_name,table,files,libs [,makename,ldflags,cflags,fflags,ismex, cc])</synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Parameters</title>

    <variablelist>
      <varlistentry>
        <term>lib_name</term>

        <listitem>
          <para>a character string, the generic name of the library without
          path and extension.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>table</term>

        <listitem>
          <para>2 column string matrix giving the table of pairs
          'scilab-name', 'interface name'</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>files</term>

        <listitem>
          <para>string matrix giving source (from Scilab 5.0) or object files
          needed for shared library creation</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>libs</term>

        <listitem>
          <para>string matrix giving extra libraries needed for shared library
          creation</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>makename</term>

        <listitem>
          <para>character string. The path of the Makefile file without
          extension.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>ldflags,cflags,fflags</term>

        <listitem>
          <para>character strings to provide options for the loader, the C
          compiler and the Fortran compiler.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>ismex</term>

        <listitem>
          <para>Internal variable to specify if we are working with mex or
          not.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>cc</term>

        <listitem>
          <para>Provide the name of the C compiler.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>

  <refsection>
    <title>Description</title>

    <para>This tool is used to create shared libraries and to generate a
    loader file which can be used to dynamically load the shared library into
    Scilab with <literal>addinter</literal></para>

    <para>Many examples are provided in
    <literal>SCI/modules/dynamic_link/examples</literal> directory. They are
    all released into the public domain.</para>

    <para><emphasis role="bold">Note that a compiler must be available on the
    system to use this function.</emphasis></para>

    <para><emphasis role="bold">Languages handle by this function are: C, C++,
    Fortran and Fortran 90.</emphasis></para>
  </refsection>

  <refsection>
    <title>Examples (C code)</title>

    <programlisting role="example"> 
//Here with give a complete example on adding new primitive to Scilab
//create the procedure files
f1=['extern double fun2();'
    'void fun1(double *x, double *y)'
    '{*y=fun2(*x)/(*x);}'];

mputl(f1,'fun1.c')

f2=['#include &lt;math.h&gt;'
    'double fun2(double x)'
    '{ return( sin(x+1.));}'];
mputl(f2,'fun2.c');

//creating the interface file
i=['#include ""stack-c.h""'
   '#include ""stackTypeVariable.h""'
   'extern int fun1 ( double *x, double *y);'
   'int intfun1(char *fname)' 
   '{'
   '  int m1,n1,l1;'
   '  CheckRhs(1,1);'
   '  CheckLhs(1,1);'
   '  GetRhsVar(1, MATRIX_OF_DOUBLE_DATATYPE, &amp;m1, &amp;n1, &amp;l1);'
   '  fun1(stk(l1),stk(l1));'
   '  LhsVar(1) = 1;'
   '  return 0;'
   '}'];
mputl(i,'intfun1.c')

//creating the shared library (a gateway, a Makefile and a loader are 
//generated. 

files=['fun1.c','fun2.c','intfun1.c'];
ilib_build('foo',['scifun1','intfun1'],files,[]);

// load the shared library 

exec loader.sce 

//using the new primitive
scifun1(33)
   </programlisting>
  </refsection>

  <refsection>
    <title>Examples (C++ code)</title>

    <programlisting role="example"> 
i=['#include &lt;string&gt;'
   'extern ""C"" {'
   '#include ""stack-c.h""'
   'int sci_cppfind(char *fname) {'
   '  int m1 = 0, n1 = 0, l1;'
   '  char *inputString1, *inputString2;'
   '  int m2 = 0, n2 = 0, l2;'
   '  int m3 = 0, n3 = 0;'
   '  double *position = NULL; /* Where we will store the position */'
   '  CheckRhs(2,2); /* Check the number of input argument */'
   '  CheckLhs(1,1); /* Check the number of output argument */'
   '  GetRhsVar(1, ""c"", &amp;m1, &amp;n1, &amp;l1); /* Retrieve the first input argument */'
   '  inputString1=cstk(l1);'
   '  GetRhsVar(2, ""c"", &amp;m2, &amp;n2, &amp;l2); /* Retrieve the second input argument */'
   '  inputString2=cstk(l2);'
   '  std::string myMessage (inputString1);'
   '  std::string search (inputString2);'
   '  m3=1;n3=1;'
   '  position = new double[1];'
   '  if (myMessage.find(search) != std::string::npos) {'
   '    position[0] = myMessage.find(search); /* The actual operation */'
   '  } else {'
   '    position[0] = -1; /* Substring not found */'
   '  }'
   '  CreateVarFromPtr(Rhs+1,""d"",&amp;m3,&amp;n3,&amp;position); /* Create the output argument */'
   '  LhsVar(1) = Rhs+1;'
   '  delete[] position;'
   '  return 0;'
   '}'
   '}'];
mputl(i,'sci_cppfind.cxx');

//creating the shared library (a gateway, a Makefile and a loader are 
//generated. 

files=['sci_cppfind.cxx'];
ilib_build('foo',['cppfind','sci_cppfind'],files,[]);

// load the shared library 

exec loader.sce 

// Small test to see if the function is actually working.
if cppfind("my very long string","long") &lt;&gt; 8 pause, end
if cppfind("my very long string","very") &lt;&gt; 3 pause, end
if cppfind("my very long string","short") &lt;&gt; -1 pause, end
   </programlisting>
  </refsection>

  <refsection>
    <title>Examples (Fortran 90 code)</title>

    <programlisting role="example"> 
sourcecode=['subroutine incrdoublef90(x,y)'
            '  implicit none'
            '  double precision, intent(in) :: x'
            '  double precision, intent(out) :: y'
            '  y=x+1'
            'end subroutine incrdoublef90'];
mputl(sourcecode,'incrdoublef90.f90');

libpath=ilib_for_link('incrdoublef90','incrdoublef90.f90',[],'f');
exec loader.sce 
n=1.;
m=call("incrdoublef90",n,1,"d","out",[1,1],2,"d");
if abs(m-2.)&gt;%eps then pause,end
n=2.;
m=call("incrdoublef90",n,1,"d","out",[1,1],2,"d");
if abs(m-3.)&gt;%eps then pause,end
   </programlisting>
  </refsection>

  <refsection>
    <title>See Also</title>

    <simplelist type="inline">
      <member><link linkend="addinter">addinter</link></member>

      <member><link linkend="link">link</link></member>

      <member><link linkend="ilib_compile">ilib_compile</link></member>

      <member><link linkend="ilib_gen_Make">ilib_gen_Make</link></member>

      <member><link
      linkend="ilib_gen_gateway">ilib_gen_gateway</link></member>

      <member><link linkend="ilib_gen_loader">ilib_gen_loader</link></member>

      <member><link linkend="ilib_for_link">ilib_for_link</link></member>
    </simplelist>
  </refsection>
</refentry>
