#######################################################################
################## Beginning of breakpoint stuff ######################
#######################################################################
#            FV 13/05/04, breakpoint and debug stuff added            #
#######################################################################
# See spipad.xml for explanations about how this feature should be used
#######################################################################
#
# Just a few words about the variables used:
#
# Highest level:
# --------------
#   funnameargs: Full command sent to Scilab (function name with arguments)
#                Generated by proc OKconf_bp
#                Used by execfile_bp
#
# One level down: ($conf level)
# ---------------
#   Elements of listboxinput
#   Elements of listboxinputval
#   Elements of spin
#   funname: function name shown by spin
#   funvars($funname): arguments list of function $funname, e.g. {arg1 arg2}
#   funvarsvals($funname,var): content of argument var from function $funname
#   funnames: list of all the different function names found by Obtainall_bp
#   funsinbuffer($textarea): same as funnames, but limited to $textarea
#
# One further level down: ($adda level)
# -----------------------
#   argname: name of currently selected function argument
#   argvalue: content of this argument
#
# Aside of these:
# ---------------
#   Breakpoints are set and managed using tags in the text widget that
#   displays the current buffer.
#   They are sent or removed in Scilab using setbpt and delbpt.
#
#######################################################################


proc checkscilabbusy {} {
    global sciprompt lang
    if [ expr [string compare $sciprompt -1] == 0 ] {
        if {$lang == "eng"} {
            set mes "Scilab is working, wait for the prompt to issue a\
                 debugger command."
            set tit "Scilab working"
        } else {
            set mes "Scilab est occupé, attendez le prompt pour\
                 effectuer des commandes de débug."
            set tit "Scilab occupé"
        }
        tk_messageBox -message $mes -title $tit -type ok -icon info
        return "busy"
    } else {
        return "OK"
    }
}

proc insertremove_bp {} {
    set textareacur [gettextareacur]
    set infun [whichfun [$textareacur index insert]]
    if {$infun !={}} {
        set i1 "insert linestart"
        set i2 "insert lineend"
        set activetags [$textareacur tag names $i1]
        if {[string first breakpoint $activetags] == -1} {
            $textareacur tag add breakpoint $i1 $i2
        } else {
            $textareacur tag remove breakpoint $i1 $i2
            $textareacur tag remove activebreakpoint $i1 $i2
        }
    }
}

proc removeall_bp {} {
    set textareacur [gettextareacur]
    set saveinsert [$textareacur index insert]
    set tagranges [$textareacur tag ranges breakpoint]
    foreach {bp_start bp_stop} $tagranges {
        $textareacur mark set insert $bp_start
        insertremove_bp
    }
    $textareacur mark set insert $saveinsert
}

proc insertremovedebug_bp {} {
    set textareacur [gettextareacur]
    if {[checkscilabbusy] == "OK"} {
        set i1 "insert linestart"
        set i2 "insert lineend"
        set activetags [$textareacur tag names $i1]
        if {[string first breakpoint $activetags] == -1} {
            $textareacur tag add breakpoint $i1 $i2
            set infun [whichfun [$textareacur index $i1]]
            if {$infun !={} } {
                set funname [lindex $infun 0]
                set lineinfun [expr [lindex $infun 1] - 1]
                set setbpcomm " setbpt(\"$funname\",$lineinfun);"
                ScilabEval $setbpcomm
            } else {
                # <TODO> .sce case
            }
        } else {
            # There was bug(s) in scilab routines/interf/matsys.f file
            # on this one: in -1-> mode, setbpt("foo",linenum) worked, but
            # delbpt("foo",linenum) did not (bp was removed from dispbpt
            # list but execution still stopped at linenum)
            # The correction has been submitted to Scilab team (see
            # bugzilla #718). If the patch is not installed, the following
            # will fail.
            $textareacur tag remove breakpoint $i1 $i2
            $textareacur tag remove activebreakpoint $i1 $i2
            set infun [whichfun [$textareacur index $i1]]
            if {$infun !={} } {
                set funname [lindex $infun 0]
                set lineinfun [expr [lindex $infun 1] - 1]
                set delbpcomm " delbpt(\"$funname\",$lineinfun);"
                ScilabEval $delbpcomm
            } else {
                # <TODO> .sce case
            }
        }
    }
}

proc reshape_bp {} {
    set textareacur [gettextareacur]
    set tagranges [$textareacur tag ranges breakpoint]
    foreach {tstart tstop} $tagranges {
        $textareacur tag remove breakpoint $tstart $tstop
        $textareacur tag add breakpoint "$tstart linestart" "$tstart lineend"
    }
}

set funnameargs ""
set funnames ""

proc execfile_bp {} {
    global funnameargs funsinbuffer
    if {[checkscilabbusy] == "OK"} {
        set removecomm [removescilab_bp "no_output"]
        set textareacur [gettextareacur]
        set tagranges [$textareacur tag ranges breakpoint]
        set setbpcomm ""
        set firstbp "true"
#        set nlins -1
 #       set nlins -2
        foreach {tstart tstop} $tagranges {
            set infun [whichfun [$textareacur index $tstart]]
            if {$infun !={} } {
                set funname [lindex $infun 0]
                set lineinfun [expr [lindex $infun 1] - 1]
                set setbpcomm [concat $setbpcomm "setbpt(\"$funname\",$lineinfun);"]
                if {$firstbp == "true"} {
                    set firstbp "false"
                    $textareacur tag remove activebreakpoint 1.0 end
                    $textareacur tag add activebreakpoint "$tstart linestart" "$tstart lineend"
                    $textareacur mark set insert "$tstart linestart"
                    $textareacur see "$tstart linestart"
                }
           } else {
                # <TODO> .sce case: I thought about:
                # - inserting pause before each bp, or
                # - inserting mode(6) plus mode(0) before each bp
                # but none is satisfactory. Using mode() will fail in loops,
                # and pause is very limited (no way to add a new bp during debug,
                # or to remove all bp to finish execution ignoring them)
#                incr nlins 1
 #               incr nlins 2
#                $textareacur insert "$tstart +$nlins l linestart" "pause\n"
 #               $textareacur insert "$tstart +$nlins l linestart" "mode(6)\nmode(0)\n"
            }
        }
        if {$funnameargs != ""} {
            execfile
# Leading spaces here to avoid possible loss of first characters
# However this does not work for long lines created by execfile (i.e.
# lines that take a long time to display or execute in Scilab window)
            if {$setbpcomm != ""} {
                ScilabEval "     $setbpcomm; $funnameargs,$removecomm"
            } else {
                ScilabEval "     $funnameargs"
            }
        } else {
            # <TODO> .sce case
##            execfile
        }
    }
}

proc removescilab_bp {outp} {
    global funnames
    if {[checkscilabbusy] == "OK"} {
        set textareacur [gettextareacur]
        set tagranges [$textareacur tag ranges breakpoint]
        set setbpcomm ""
        if {$funnames != ""} {
            foreach fun $funnames {
                set setbpcomm [concat $setbpcomm "delbpt(\"$fun\");"]
            }
            if {$outp != "no_output"} {
                ScilabEval " $setbpcomm"
            }
        } else {
            # <TODO> .sce case
        }
        return $setbpcomm
    }
}

proc stepbystep_bp {} {
# <TODO>
# I have no satisfactory solution for the time being.
# The heart of the matter with step by step execution is that
# once the execution is stopped there is no way of knowing what is the next
# line of code to execute. Of course, it is usually the next code line in the
# sci file, but this is not necessarily true in for, while, if, and case
# structures. I do not foresee any other remedy than a complete code analysis
# performed in tcl (!), but this is a huge task I'm not prepared to go into.
# Moreover, all this analysis is already (and surely better) done by the
# Scilab interpreter, therefore the best way would probably be to add a new
# Scilab function that would return the line number of the next instruction to
# be executed. This should no be such a tricky thing to do drawing inspiration
# e.g. from setbpt. Then I would have to hack a way of returning a result to
# tcl from a ScilabEval. 
# Note: There is a similar issue with active bp tag in conditional structures.
# Currently the "next active bp" is the next one in the file
# but this becomes wrong if the bp is in a for, while, if or case
    tk_messageBox -message "Sorry, step execution not yet implemented!"
}

proc resume_bp {} {
# <TODO> correct wrong active bp tag when bp is in conditional structure
# Solution to this is similar to what is explained in proc stepbystep_bp 
 #   global funnameargs
    if {[checkscilabbusy] == "OK"} {
        set textareacur [gettextareacur]
        set actbprange [$textareacur tag ranges activebreakpoint]
        if {$actbprange != {} } {
            set actstart [lindex $actbprange 0]
            set actstop [lindex $actbprange 1]
            $textareacur tag remove activebreakpoint $actstart $actstop
            set nextbprange [$textareacur tag nextrange breakpoint $actstop]
            if {$nextbprange != {} } {
                set newipos [lindex $nextbprange 0]
                $textareacur tag add activebreakpoint $newipos [lindex $nextbprange 1]
                $textareacur mark set insert $newipos
                $textareacur see $newipos
            }
        }
 #       if {$funnameargs != ""} {
            ScilabEval " resume"
 #       } else {
            # <TODO> .sce case
            # Sending \n is if mode(6) mode(0) is used. If pause, there is no
            # need to ditinguish between .sci and .sce (resume is sent for both)
 #           ScilabEval " "
 #       }
    }
}

proc goonwo_bp {} {
    if {[checkscilabbusy] == "OK"} {
        [gettextareacur] tag remove activebreakpoint 1.0 end
        removescilab_bp "with_output"
        ScilabEval " resume"
    }
}

proc dispcallstack_bp {} {
    if {[checkscilabbusy] == "OK"} {
        ScilabEval " whereami()"
    }
}

proc canceldebug_bp {} {
    if {[checkscilabbusy] == "OK"} {
        [gettextareacur] tag remove activebreakpoint 1.0 end
        ScilabEval " abort"
        removescilab_bp "with_output"
    }
}

proc configurefoo_bp {} {
    global pad conf lang
    global listboxinput listboxinputval listboxscrolly spin buttonAdd
    global funnames funvars funvarsvals funnameargs
    set conf $pad.conf
    catch {destroy $conf}
    toplevel $conf
    if {$lang == "eng"} {
        wm title $conf "Configure execution"
    } else {
        wm title $conf "Configurer l'exécution"
    }
    setwingeom $conf
    frame $conf.f

    frame $conf.f.f1
    if {$lang == "eng"} {
        set tl "Function name:"
    } else {
        set tl "Nom de la fonction :"
    }
    label $conf.f.f1.label -text $tl -width 20
    set spin $conf.f.f1.spinbox
    spinbox $spin -width 30 -command "spinboxbuttoninvoke" \
                  -values $funnames -state readonly -takefocus 0
    set oppar [string first "\(" $funnameargs]
    set funname [string range $funnameargs 0 [expr $oppar-1]]
    if {$funname != "" } {
        $spin set $funname
    } else {
        $spin set [lindex $funnames 0]
        set funname [$spin get]
    }
    if {$lang == "eng"} {
        set bl "Obtain"
    } else {
        set bl "Obtenir"
    }
    button $conf.f.f1.buttonObtain -text $bl -command "Obtainall_bp"\
           -width 10 -underline 1
    pack $conf.f.f1.label $spin $conf.f.f1.buttonObtain \
         -side left -padx 4
    pack $conf.f.f1

    frame $conf.f.f2
    frame $conf.f.f2.f2l
    if {$lang == "eng"} {
        set tl "Input arguments:"
    } else {
        set tl "Arguments d'entrée :"
    }
    label $conf.f.f2.f2l.label -text $tl
    if {$lang == "eng"} {
        set bl "Add/Change"
    } else {
        set bl "Ajouter/Modifier"
    }
    set buttonAdd $conf.f.f2.f2l.buttonAdd
    button $buttonAdd -text $bl -command "Addarg_bp" -width 20 -underline 0
    if {$lang == "eng"} {
        set bl "Remove"
    } else {
        set bl "Supprimer"
    }
    button $conf.f.f2.f2l.buttonRemove -text $bl -command "Removearg_bp"\
           -width 20 -underline 0
    pack $conf.f.f2.f2l.label $buttonAdd $conf.f.f2.f2l.buttonRemove -pady 4
    frame $conf.f.f2.f2r
    set listboxinput $conf.f.f2.f2r.listboxinput
    set listboxscrolly $conf.f.f2.f2r.yscroll
    scrollbar $listboxscrolly -command "scrollyboth_bp"
    listbox $listboxinput -height 6 -yscrollcommand "scrollyrightandscrollbar_bp" \
                          -takefocus 0
    set listboxinputval $conf.f.f2.f2r.listboxinputval
    listbox $listboxinputval -height 6 -yscrollcommand "scrollyleftandscrollbar_bp" \
                          -takefocus 0
    if {[info exists funvars($funname)]} {
        foreach var $funvars($funname) {
            $listboxinput insert end $var
            $listboxinputval insert end $funvarsvals($funname,$var)
        }
        $listboxinput selection set 0
        $listboxinput see 0
    }
    pack $listboxinput $listboxscrolly $listboxinputval -side left \
            -expand 1 -fill both -padx 2
    pack $conf.f.f2.f2l $conf.f.f2.f2r -side left -padx 10
    pack $conf.f.f2 -pady 4

    frame $conf.f.f9
    button $conf.f.f9.buttonOK -text "OK" -command "OKconf_bp $conf"\
           -width 10 -height 1 -underline 0
    if {$lang == "eng"} {
        set bl "Cancel"
    } else {
        set bl "Annuler"
    }
#    button $conf.f.f9.buttonCancel -text $bl -command "Cancelconf_bp $conf"\
#           -width 10 -underline 0
#    pack $conf.f.f9.buttonOK $conf.f.f9.buttonCancel -side left -padx 10
    pack $conf.f.f9.buttonOK
    pack $conf.f.f9 -pady 4

    pack $conf.f
#    bind $conf <Return> "OKconf_bp $conf"
    bind $conf <Return> "Addarg_bp"
#    bind $conf <Escape> "Cancelconf_bp $conf"
    bind $conf <Escape> "OKconf_bp $conf"
    bind $conf <BackSpace> "Removearg_bp"
    bind $conf <Delete> "Removearg_bp"
    bind $listboxinputval <<ListboxSelect>> {selectininputval_bp}
    bind $listboxinput <ButtonPress-3> {set itemindex [dragitem_bp %y]}
    bind $listboxinput <ButtonRelease-3> {dropitem_bp $itemindex %y}
    bind $conf <Up> {scrollarrows_bp up}
    bind $conf <Down> {scrollarrows_bp down}
    bind $conf <MouseWheel> {if {%D<0} {scrollarrows_bp down}\
                                       {scrollarrows_bp up}}
    focus $buttonAdd
    grab $conf
    if {$funnames == ""} {Obtainall_bp}
    if {$funnames == ""} {OKconf_bp $conf}
}

proc scrollyboth_bp {args} {
    global listboxinput listboxinputval
    eval "$listboxinput yview $args"
    eval "$listboxinputval yview $args"
}
proc scrollyleftandscrollbar_bp {x y} {
    global listboxscrolly listboxinput listboxinputval
    eval "$listboxscrolly set $x $y"
    set firstvisible [expr round([lindex [$listboxinputval yview] 0] \
                               * [$listboxinputval size])]
    eval "$listboxinput yview $firstvisible"
}
proc scrollyrightandscrollbar_bp {x y} {
    global listboxscrolly listboxinput listboxinputval
    eval "$listboxscrolly set $x $y"
    set firstvisible [expr round([lindex [$listboxinput yview] 0] \
                               * [$listboxinput size])]
    eval "$listboxinputval yview $firstvisible"
}
proc selectininputval_bp {} {
    global listboxinput listboxinputval
    set selecteditem [$listboxinputval curselection]
    if {$selecteditem != ""} {
        $listboxinputval selection clear $selecteditem
        $listboxinput selection set $selecteditem
    }
}
proc spinboxbuttoninvoke {} {
    global spin listboxinput listboxinputval funvars funvarsvals
    $listboxinput delete 0 [$listboxinput size]
    $listboxinputval delete 0 [$listboxinputval size]
    set funname [$spin get]
    if {[info exists funvars($funname)]} {
        foreach var $funvars($funname) {
            $listboxinput insert end $var
            $listboxinputval insert end $funvarsvals($funname,$var)
        }
    $listboxinput selection set 0
    $listboxinput see 0
    }
}

proc scrollarrows_bp {dir} {
    global listboxinput
    set ind [$listboxinput curselection]
    if {$ind != ""} {
        if {$dir == "down"} {
            if {$ind < [expr [$listboxinput size] - 1]} {
                $listboxinput selection clear $ind
                $listboxinput selection set [expr $ind + 1]
                $listboxinput see [expr $ind + 1]
            }
        } else {
            if {$ind > 0} {
                $listboxinput selection clear $ind
                $listboxinput selection set [expr $ind - 1]
                $listboxinput see [expr $ind - 1]
            }
        }
    }
}

set curdropind 0

proc dragitem_bp {dragpos} {
    global listboxinput curdropind
    set se [$listboxinput curselection]
    if {$se != "" } {
        $listboxinput selection clear $se
        $listboxinput selection set @0,$dragpos
        set curdropind [$listboxinput curselection]
        bind $listboxinput <Motion> {set curdropind [showdroppos_bp $curdropind %y]}
    }
    return [$listboxinput curselection]
}

proc dropitem_bp {dragind droppos} {
    global listboxinput listboxinputval spin funvars curdropind
    if {$dragind != "" } {
        set funname [$spin get]
        set dropind [$listboxinput index @0,$droppos]
        set dragitem [$listboxinput get $dragind]
        if {$dragind != $dropind} {
            $listboxinput insert $dropind $dragitem
            $listboxinputval insert $dropind [$listboxinputval get $dragind]
            set funvars($funname) [linsert $funvars($funname) $dropind $dragitem]
            if {$dropind < $dragind} {
                incr dragind
                incr curdropind
            } else {
                incr dropind -1
            }
            $listboxinput delete $dragind
            $listboxinput selection set $dropind
            $listboxinputval delete $dragind
            set funvars($funname) [lreplace $funvars($funname) $dragind $dragind]
        }
        $listboxinput itemconfigure $curdropind -background white
        bind $listboxinput <Motion> {}
    }
}

proc showdroppos_bp {oldcurdropind droppos} {
    global listboxinput
    if {$droppos < 1} {
        if {$oldcurdropind > 0} {
            $listboxinput see [expr $oldcurdropind - 1]
        }
    }
# $maxi computation is unperfect, but should work in most cases
# The best: to get $listboxinput height in pixels - how?
    set maxi [$listboxinput bbox $oldcurdropind]
    set maxi [expr [lindex $maxi 3] + 1]
    set maxi [expr $maxi * [$listboxinput cget -height] + 4]
    if {$droppos > $maxi} {
        if {$oldcurdropind < [expr [$listboxinput size] - 1]} {
            $listboxinput see [expr $oldcurdropind + 1]
        }
    }
    set dropind [$listboxinput index @0,$droppos]
    if {$oldcurdropind != $dropind} {
        $listboxinput itemconfigure $oldcurdropind -background white
        $listboxinput itemconfigure $dropind -background lightblue
    }
    return $dropind
}

proc OKconf_bp {w} {
    global listboxinput listboxinputval spin
    global funnameargs
    set funname [$spin get]
    if {$funname != ""} {
        set orderOK [checkarglist $funname]
        if {$orderOK == "true"} {
            set strargs ""
            for {set i 0} {$i < [$listboxinput size]} {incr i} {
                set argvalue [$listboxinputval get $i]
                set strargs "$strargs,$argvalue"
            }
            set strargs [string range $strargs 1 end]
            set funnameargs "$funname\($strargs\)"
        }
    } else {
        set funnameargs ""
    }
    destroy $w
}

proc checkarglist {funname} {
# Because the user could add input variables (in the buffer text) to the
# currently selected function, checking the argument list cannot just
# rely on the latest Obtainall_bp
    global listoftextarea funvars lang
    set pat "\\mfunction\\M.*\\m$funname\\M"
    set orderOK "false"
    foreach textarea $listoftextarea {
        set ex [$textarea search -regexp $pat 0.0 end]
        if {$ex != "" } {
            while {[lsearch [$textarea tag names $ex] "textquoted"] != -1 || \
                   [lsearch [$textarea tag names $ex] "rem2"] != -1 } {
                set ex [$textarea search -regexp $pat "$ex+8c" end]
                if {$ex == ""} break
            }
            if {$ex != "" } {
                set infun [whichfun [$textarea index "$ex +1l"] $textarea]
                set funline [lindex $infun 2]
                set oppar [string first "\(" $funline]
                set clpar [string first "\)" $funline]
                set listvars [string range $funline [expr $oppar+1] [expr $clpar-1]]
                set listvars [string map {, " "} $listvars]
                set orderOK "true"
                set i 0
                foreach var $funvars($funname) {
                    if {$var != [lindex $listvars $i]} {
                        set orderOK "false"
                        break
                    } else {
                        incr i
                    }
                }
            }
        }
    }
    if {$orderOK != "true" } {
        if {$lang == "eng" } {
            set mes "Function name or input arguments do not match definition\
                     of the function $funname in the file!\n\nCheck function\
                     name and arguments (names, order) in the configuration dialog.\
                     \nArguments order can be changed using drap and drop with\
                     right mouse button in the arguments listbox."
            set tit "Error in selected function name or arguments"
        } else {
            set mes "Le nom de la fonction ou ses arguments ne correspondent pas\
                     à la définition de la fonction $funname dans le fichier!\n\n\
                     Vérifier le nom de la fonction et ses arguments (nom, ordre\
                     d'apparition) dans la boîte de dialogue de configuration.\n\
                     L'ordre des arguments peut être modifié par glisser/déposer\
                     avec le bouton droit de la souris."
            set tit "Erreur sur la fonction sélectionnée ou ses arguments"
        }
        tk_messageBox -message $mes -icon warning -title $tit
    }
    return $orderOK
}

#proc Cancelconf_bp {w} {
# Better always close the window with OK button. Saves variables management.
#    destroy $w
#}

proc Obtainall_bp {} {
    global spin listboxinput listboxinputval funnames funvars funvarsvals
    global funsinbuffer
    set textarea [gettextareacur]
    set funsinbuffer($textarea) ""
    set nextfun [$textarea search -exact -forwards -regexp\
                 "\\mfunction\\M" 0.0 end ]
    set firstfuninbuffer "true"
    while {$nextfun != ""} {
        while {[lsearch [$textarea tag names $nextfun] "textquoted"] != -1 || \
               [lsearch [$textarea tag names $nextfun] "rem2"] != -1 } {
            set nextfun [$textarea search -exact -forwards -regexp\
                         "\\mfunction\\M" "$nextfun +8c" end]
            if {$nextfun == ""} break
        }
        if {$nextfun != ""} {
            set infun [whichfun [$textarea index "$nextfun +1l"]]
        } else {
            set infun {}
        }
        if {$infun != {} } {
            $spin configure -state normal
            $spin delete 0 end
            set funname [lindex $infun 0]
            set precval [$spin cget -values]
            if {[lsearch $precval $funname] == -1} {
                $spin configure -values "$precval $funname"
            }
            $spin configure -state readonly
            if {$firstfuninbuffer == "true"} {
                set firstfuninbuffer "false"
                set funtoset $funname
            }
            set funline [lindex $infun 2]
            $listboxinput delete 0 [$listboxinput size]
            $listboxinputval delete 0 [$listboxinputval size]
            set oppar [string first "\(" $funline]
            set clpar [string first "\)" $funline]
            set listvars [string range $funline [expr $oppar+1] [expr $clpar-1]]
            set listvars [string map {, " "} $listvars]
            foreach var $listvars {
                $listboxinput insert end $var
                set funvarsvals($funname,$var) ""
                $listboxinputval insert end $funvarsvals($funname,$var)
            }
            $listboxinput selection set 0
            $listboxinput see 0
            set funvars($funname) $listvars
            set funsinbuffer($textarea) "$funsinbuffer($textarea) $funname"
            set nextfun [$textarea search -exact -forwards -regexp\
                         "\\mfunction\\M" "$nextfun +8c" end]
        }
    }
    set funnames [$spin cget -values]
    if {[info exists funtoset]} {
        $spin set $funtoset
    } else {
        $spin set [lindex $funnames 0]
    }
    spinboxbuttoninvoke
    $listboxinput see 0
}

proc Addarg_bp {} {
    global conf lang
    global argname argvalue listboxinput listboxinputval spin
    global buttonAdd
    set pos [$listboxinput curselection]
    if {$pos == ""} {set pos 0}
    if {[$spin get] != ""} {
        set adda $conf.adda
        toplevel $adda
        if {$lang == "eng"} {
            wm title $adda "Add argument"
        } else {
            wm title $adda "Ajouter un argument"
        }
        setwingeom $adda
        set selecteditem [$listboxinput curselection]
        if {$selecteditem != ""} {
            set argname [$listboxinput get $selecteditem]
            set argvalue [$listboxinputval get $selecteditem]
        }
        frame $adda.f
        frame $adda.f.f1
        if {$lang == "eng"} {
            set tl "Argument:"
        } else {
            set tl "Argument:"
        }
        label $adda.f.f1.label -text $tl -width 10
        entry $adda.f.f1.entry  -textvariable argname -width 20 
        pack $adda.f.f1.label $adda.f.f1.entry -side left
        $adda.f.f1.entry selection range 0 end
        pack $adda.f.f1
        frame $adda.f.f2
        if {$lang == "eng"} {
            set tl "Value:"
        } else {
            set tl "Valeur:"
        }
        label $adda.f.f2.label -text $tl -width 10
        entry $adda.f.f2.entry  -textvariable argvalue -width 20 
        pack $adda.f.f2.label $adda.f.f2.entry -side left
        $adda.f.f2.entry selection range 0 end
        pack $adda.f.f2
        frame $adda.f.f9
        button $adda.f.f9.buttonOK -text "OK" -command "OKadda_bp $adda $pos"\
               -width 10 -height 1 -underline 0
        if {$lang == "eng"} {
            set bl "Cancel"
        } else {
            set bl "Annuler"
        }
        button $adda.f.f9.buttonCancel -text $bl -command "Canceladda_bp $adda $pos"\
               -width 10 -underline 0
        pack $adda.f.f9.buttonOK $adda.f.f9.buttonCancel -side left -padx 10
        pack $adda.f.f9 -pady 4
        pack $adda.f
        bind $adda <Return> "OKadda_bp $adda $pos"
        bind $adda <Escape> "Canceladda_bp $adda $pos"
        focus $adda.f.f2.entry
        grab $adda
    }
    focus $buttonAdd
}

proc OKadda_bp {w pos} {
    global argname argvalue listboxinput listboxinputval
    global spin funvars funvarsvals
    if {$argname!= ""} {
        set listboxinputelts [$listboxinput get 0 end]
        set alreadyexists "false"
        set eltindex 0
        foreach elt $listboxinputelts {
            if {$argname == $elt} {
                set alreadyexists "true"
                break
            } else {
                incr eltindex
            }
        }
        set funname [$spin get]
        if {$alreadyexists == "false"} {
            set pos [expr $pos + 1]
            $listboxinput insert $pos $argname
            $listboxinputval insert $pos $argvalue

            $listboxinput selection set $pos
            $listboxinput see $pos
            set funvars($funname) [linsert $funvars($funname) $pos $argname]
       } else {
            set nextone [expr $eltindex + 1]
            if {$nextone >= [$listboxinput size]} {
                set nextone 0
            }
            $listboxinput selection set $nextone
            $listboxinput see $nextone
            $listboxinputval delete $eltindex
            $listboxinputval insert $eltindex $argvalue
        }
        set funvarsvals($funname,$argname) $argvalue
    }
    destroy $w
}

proc Canceladda_bp {w pos} {
    global listboxinput
    destroy $w
    $listboxinput selection set $pos
}

proc Removearg_bp {} {
    global listboxinput listboxinputval spin
    global funvars funvarsvals
    set selecteditem [$listboxinput curselection]
    if {$selecteditem != ""} {
        set funname [$spin get]
        set argname [$listboxinput get $selecteditem]
        unset funvarsvals($funname,$argname)
        set funvars($funname) [lreplace $funvars($funname) \
                                        $selecteditem $selecteditem]
        $listboxinput delete $selecteditem
        $listboxinput see $selecteditem
        $listboxinputval delete $selecteditem
        if {$selecteditem < [expr [$listboxinput size] ]} {
            $listboxinput selection set $selecteditem
        } else {
            $listboxinput selection set [expr [$listboxinput size] - 1]
        }
    }
}

proc removefuns_bp {textarea} {
    global funsinbuffer funvars funvarsvals funnames funnameargs
    if {[info exists funsinbuffer($textarea)]} {
        foreach fun $funsinbuffer($textarea) {
            if {[info exists funvars($fun)]} {
                foreach arg $funvars($fun) {
                    unset funvarsvals($fun,$arg)
                }
                unset funvars($fun)
            }
            set pos [lsearch $funnames $fun]
            set funnames [lreplace $funnames $pos $pos]
            set oppar [expr [string first "\(" $funnameargs] - 1]
            set curfunname [string range $funnameargs 0 $oppar]
            if {$curfunname == $fun} {
                set funnameargs "[lindex $funnames 0]("
            }
        }
        if {$funnameargs != "("} {
            set funname [string range $funnameargs 0 [expr [string length $funnameargs] - 2]]
            set strargs ""
            if {[info exists funvars($funname)]} {
                foreach var $funvars($funname) {
                    set argvalue $funvarsvals($funname,$var)
                    set strargs "$strargs,$argvalue"
                }
                set strargs [string range $strargs 1 end]
            }
            set funnameargs "$funname\($strargs\)"
        } else {
            set funnameargs ""
        }
    }
}

#######################################################################
##################### End of breakpoint stuff #########################
#######################################################################
