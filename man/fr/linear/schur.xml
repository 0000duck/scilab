<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "../../man.dtd">
<MAN>
  <LANGUAGE>fr</LANGUAGE>
  <TITLE>schur  </TITLE>
  <TYPE>Scilab Function  </TYPE>
  <DATE>April 1993  </DATE>
  <SHORT_DESCRIPTION name="schur"> décomposition de Schur ordonnée des
  matrices et faisceaux de matrices</SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
  <CALLING_SEQUENCE_ITEM>[U,T] = schur(A)   </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[U,dim]=schur(A,flag)  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[U,dim]=schur(A,extern1)</CALLING_SEQUENCE_ITEM>

  <CALLING_SEQUENCE_ITEM>[As,Es [,Q,Z]]=schur(A,E)  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[As,Es [,Q],Z,dim] = schur(A,E,flag)   </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[Z,dim] = schur(A,E,flag)   </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[As,Es [,Q],Z,dim]= schur(A,E,extern2)  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[Z,dim]= schur(A,E,extern2)  </CALLING_SEQUENCE_ITEM>

  </CALLING_SEQUENCE>
  <PARAM>
 <PARAM_INDENT>

  <PARAM_ITEM>
  <PARAM_NAME>A  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : matrice carrée réelle ou complexe. Pour la forme ordonnée <VERB>A</VERB> est supposée réelle.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>E  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : matrice carrée réelle ou complexe de même dimension que <VERB>A</VERB>.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>flag  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : chaîne de caractères (<VERB>&apos;c&apos;</VERB> ou <VERB>&apos;d&apos;</VERB>)
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>extern1  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : identificateur d'une fonction externe , voir ci-dessous.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 
 <PARAM_ITEM>
  <PARAM_NAME>extern2  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : identificateur d'une fonction externe , voir ci-dessous.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 

  <PARAM_ITEM>
  <PARAM_NAME>U  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : matrice unitaire carrée.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>Q  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : matrice unitaire carrée.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>Z  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : matrice unitaire carrée.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>T  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : matrice carrée réelle ou complexe, triangulaire supérieure ou quasi-triangulaire supérieure
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>As  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : matrice carrée réelle ou complexe, triangulaire supérieure ou quasi-triangulaire supérieure
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>Es  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : matrice carrée réelle ou complexe, triangulaire supérieure.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 
  <PARAM_ITEM>
  <PARAM_NAME>dim  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : entier
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

 </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
  <P>
    Forme de Schur, Forme de Schur ordonnée.
  </P>
   <DESCRIPTION_ITEM  label='-  Forme de Schur des matrices'>
   </DESCRIPTION_ITEM>
    <DESCRIPTION_ITEM label=' * Forme de Schur usuelle'>
     <VERB> [U,T] = schur(A)</VERB> produit une matrice de Schur
     <VERB>T</VERB> et une matrice unitaire <VERB>U</VERB> telles que
     <VERB>A = U*T*U&apos;</VERB> et <VERB>U&apos;*U =
     eye(U)</VERB>. Utilisée sans argument en sortie,
     schur(<VERB>A</VERB>) renvoie <VERB>T</VERB>. Si <VERB>A</VERB>
     est complexe, la forme de Schur complexe est renvoyée dans la
     matrice <VERB>T</VERB>. la forme de Schur complexe est
     triangulaire supérieure avec les valeurs propres de <VERB>A</VERB>
     sur la diagonale. Si <VERB>A</VERB> est réelle, la forme de Schur
     réelle est renvoyée. Dans la forme de Schur réelle les valeurs
     propres réelles sont sur la diagonale et les valeurs propres
     complexes sont les valeurs propres des blocs 2 x 2 sur la
     diagonale.
   </DESCRIPTION_ITEM>
   <DESCRIPTION_ITEM  label=' * Forme de Schur ordonnée'>
   </DESCRIPTION_ITEM>
    <P>
    <VERB>[U,dim]=schur(A,&apos;c&apos;)</VERB> 
    renvoie une matrice unitaire <VERB>U</VERB> transformant
    <VERB>A</VERB> en forme de Schur. De plus, les <VERB>dim/</VERB>
    premières colonnes de <VERB>U</VERB> forment une base du
    sous-espace propre de <VERB>A</VERB> associé aux valeurs propres
    ayant une partie réelle négative (sous espace propre stable
    &quot;en temps continu&quot;).
    </P>
    <P>
    <VERB>[U,dim]=schur(A,&apos;d&apos;)</VERB> 
    renvoie une matrice unitaire <VERB>U</VERB> transformant
    <VERB>A</VERB> en forme de Schur. De plus, les <VERB>dim/</VERB>
    premières colonnes de <VERB>U</VERB> forment une base du
    sous-espace propre de <VERB>A</VERB> associé aux valeurs propres
    de module plus petit que 1 (sous espace propre stable &quot;en
    temps discret&quot;).
    </P>
    <P>
    <VERB> [U,dim]=schur(A,extern1)</VERB>
    renvoie une matrice unitaire <VERB>U</VERB> transformant
    <VERB>A</VERB> en forme de Schur. De plus, les <VERB>dim/</VERB>
    premières colonnes de <VERB>U</VERB> forment une base du
    sous-espace propre de <VERB>A</VERB> associé aux valeurs propres
    sélectionnée par la fonction externe <VERB>extern1</VERB> (voir
    external pour les details).
    </P>
     <DESCRIPTION_ITEM  label='  + si'> 
       <VERB>extern1</VERB> est une fonction Scilab, elle doit avoir la
       liste d'appel suivante: <VERB>s=extern1(Ev)</VERB>, ou
       <VERB>Ev</VERB> est une valeur propre et <VERB>s</VERB> un booléen
     </DESCRIPTION_ITEM>
     <DESCRIPTION_ITEM  label='  + si'> 
      <VERB>extern1</VERB> est une chaîne de caractères donnant le nom
      d'une procédure C ou Fortran, cette procédure doit avoir la liste
      d'appel suivante: 
      <VERB>int extern1(double *EvR, double *EvI)</VERB>
      où <VERB>EvR</VERB> et <VERB>EvI</VERB> sont les parties réelles
      et complexes de la valeur propre à tester. Une valeur de retour
      non nulle signifie que la valeur propre est sélectionnée.
    </DESCRIPTION_ITEM>

   <DESCRIPTION_ITEM  label='- Forme de Schur des faisceaux de matrices '>
   </DESCRIPTION_ITEM>
    <DESCRIPTION_ITEM label=' * Forme de Schur généralisée usuelle'> 
   </DESCRIPTION_ITEM>
     <P>
     <VERB>[As,Es] = schur(A,E)</VERB> retourne une matrice
     quasi-triangulaire <VERB>As</VERB> et une matrice triangulaire
     <VERB>Es</VERB> qui forment la forme de schur généralisée  du faisceau <VERB>s*E-A</VERB>.
     </P>
     <P>
     <VERB>[As,Es,Q,Z] = schur(A,E)</VERB> retourne de plus deux matrices
     unitaire <VERB>Q</VERB> et <VERB>Z</VERB> telles que
     <VERB>As=Q&apos;*A*Z</VERB> et <VERB>Es=Q&apos;*E*Z</VERB>.
    </P>

    <DESCRIPTION_ITEM label=' * Forme de Schur généralisée ordonnée '> 
    </DESCRIPTION_ITEM>
     <P>
     <VERB>[As,Es,Z,dim] = schur(A,E,&apos;d&apos;)</VERB> retourne de
     forme de Schur généralisée du faisceau <VERB>s*E-A</VERB>>. De
     plus les <VERB>dim</VERB> premières colonnes de <VERB>Z</VERB>
     forment  une base du sous espace propre à droite associé aux valeurs
     propres dont le modules est plus petit que 1 (sous espace stable
     pour le "temps discret").
     </P>
     <P>
    <VERB>[As,Es,Z,dim] = schur(A,E,&apos;c&apos;)</VERB> retourne de
     forme de Schur généralisée du faisceau <VERB>s*E-A</VERB>>. De
     plus les <VERB>dim</VERB> premières colonnes de <VERB>Z</VERB>
     forment une base du sous espace propre à droite associé aux valeurs
     propres dont la partie réelle est neégative 1 (sous espace stable
     pour le "temps continu").
     </P>
     <P>   
     <VERB>[As,Es,Z,dim] = schur(A,E,extern2)</VERB> retourne de
     forme de Schur généralisée du faisceau <VERB>s*E-A</VERB>>. De
     plus les <VERB>dim</VERB> premières colonnes de <VERB>Z</VERB>
     forment une base du sous espace propre à droite associé aux valeurs
     propres ont été sélectionnées par la règle définie par
     <VERB>extern2</VERB>
     </P>
     <DESCRIPTION_ITEM  label='  + if'> 
     <VERB>extern2</VERB> est une fonction Scilab 
     elle doit avoir la
     liste d'appel suivante: <VERB>s=extern2(Alpha,Beta)</VERB>, où
     <VERB>Alpha</VERB> et <VERB>Beta</VERB> définissent une valeur
     propre généralisée  et <VERB>s</VERB> un booléen.
     </DESCRIPTION_ITEM>
     <DESCRIPTION_ITEM  label='  + if'> 
     <VERB>extern2</VERB> est une chaîne de caractères donnant le nom
     d'une procédure C ou Fortran, cette procédure doit avoir la liste
     d'appel suivante: 
     <VERB> iint extern2(double *AlphaR, double *AlphaI, double *Beta)</VERB>
     si <VERB>A</VERB> et <VERB>E</VERB> sont des matrices réelles ou
     <VERB>int extern2(double *AlphaR, double *AlphaI, double *BetaR, double *BetaI)
     </VERB>
     si <VERB>A</VERB> et <VERB>E</VERB> sont des matrices complexes
     <VERB>Alpha</VERB> et <VERB>Beta</VERB> définissent une valeur
     propre généralisée. Une valeur de retour
     non nulle signifie que la valeur propre est sélectionnée.
    </DESCRIPTION_ITEM>
 </DESCRIPTION>
  <ITEMIZE label='REFERENCES'>
  <P>
    La forme de schur des matrices est basée sur les routines Lapack  DGEES and ZGEES.
  </P>
  <P>
    La forme de schur des faisceaux est basée sur les routines Lapack  DGEES and ZGEES.
  </P>
  </ITEMIZE>
  <EXAMPLE><![CDATA[
/Forme de Schur des matrices
//--------------------------
A=diag([-0.9,-2,2,0.9]);X=rand(A);A=inv(X)*A*X;
[U,T]=schur(A);T

[U,dim,T]=schur(A,'c');
T(1:dim,1:dim)      //valeurs propres stable (continu)

function t=mytest(Ev),t=abs(Ev)<0.95,endfunction
[U,dim,T]=schur(A,mytest);
T(1:dim,1:dim)  

// La meme fonction en C (un compilateur est nécessaire)
C=['int mytest(double *EvR, double *EvI) {' //le code C
   'if (*EvR * *EvR + *EvI * *EvI < 0.9025) return 1;'
   'else return 0; }';]
mputl(C,TMPDIR+'/mytest.c')
link(G_make(TMPDIR+'/mytest.o','c'), 'mytest',"C")
[U,dim,T]=schur(A,'mytest');
//SCHUR FORM OF A PENCIL
//----------------------
F=[-1,%s, 0,   1;
    0,-1,5-%s, 0;
    0, 0,2+%s, 0;
    1, 0, 0, -2+%s];
A=coeff(F,0);E=coeff(F,1);
[As,Es,Q,Z]=schur(A,E);
Q'*F*Z //It is As+%s*Es


[As,Es,Z,dim] = schur(A,E,'c')
function t=mytest(Alpha,Beta),t=real(Alpha)<0,endfunction
[As,Es,Z,dim] = schur(A,E,mytest)

//La meme fonction en Fortran (un compilateur est nécessaire)
ftn=['integer function mytest(ar,ai,b)' //the fortran code
      'double precision ar,ai,b'
      'mytest=0'
      'if(ar.lt.0.0d0) mytest=1'
      'end']
mputl('      '+ftn,TMPDIR+'/mytest.f')
link(G_make(TMPDIR+'/mytest.o'), 'mytest',"F")

[As,Es,Z,dim] = schur(A,E,'mytest')

 ]]></EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>gschur</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>ricc</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>pbig</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>psmall</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>
</MAN>
